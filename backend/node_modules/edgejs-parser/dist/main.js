var Ss = typeof global == "object" && global && global.Object === Object && global, Qi = typeof self == "object" && self && self.Object === Object && self, pe = Ss || Qi || Function("return this")(), J = pe.Symbol, _s = Object.prototype, Ji = _s.hasOwnProperty, ea = _s.toString, st = J ? J.toStringTag : void 0;
function ta(t) {
  var e = Ji.call(t, st), n = t[st];
  try {
    t[st] = void 0;
    var r = !0;
  } catch {
  }
  var s = ea.call(t);
  return r && (e ? t[st] = n : delete t[st]), s;
}
var na = Object.prototype, ra = na.toString;
function sa(t) {
  return ra.call(t);
}
var ia = "[object Null]", aa = "[object Undefined]", Ar = J ? J.toStringTag : void 0;
function be(t) {
  return t == null ? t === void 0 ? aa : ia : Ar && Ar in Object(t) ? ta(t) : sa(t);
}
function oe(t) {
  return t != null && typeof t == "object";
}
var oa = "[object Symbol]";
function qt(t) {
  return typeof t == "symbol" || oe(t) && be(t) == oa;
}
function Zt(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length, s = Array(r); ++n < r; )
    s[n] = e(t[n], n, t);
  return s;
}
var N = Array.isArray, Rr = J ? J.prototype : void 0, Ir = Rr ? Rr.toString : void 0;
function Os(t) {
  if (typeof t == "string")
    return t;
  if (N(t))
    return Zt(t, Os) + "";
  if (qt(t))
    return Ir ? Ir.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
var ca = /\s/;
function ua(t) {
  for (var e = t.length; e-- && ca.test(t.charAt(e)); )
    ;
  return e;
}
var la = /^\s+/;
function ha(t) {
  return t && t.slice(0, ua(t) + 1).replace(la, "");
}
function ee(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var Sr = NaN, fa = /^[-+]0x[0-9a-f]+$/i, da = /^0b[01]+$/i, pa = /^0o[0-7]+$/i, Ea = parseInt;
function ga(t) {
  if (typeof t == "number")
    return t;
  if (qt(t))
    return Sr;
  if (ee(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = ee(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = ha(t);
  var n = da.test(t);
  return n || pa.test(t) ? Ea(t.slice(2), n ? 2 : 8) : fa.test(t) ? Sr : +t;
}
var _r = 1 / 0, Ta = 17976931348623157e292;
function ma(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = ga(t), t === _r || t === -_r) {
    var e = t < 0 ? -1 : 1;
    return e * Ta;
  }
  return t === t ? t : 0;
}
function Qt(t) {
  var e = ma(t), n = e % 1;
  return e === e ? n ? e - n : e : 0;
}
function Ye(t) {
  return t;
}
var Aa = "[object AsyncFunction]", Ra = "[object Function]", Ia = "[object GeneratorFunction]", Sa = "[object Proxy]";
function Ne(t) {
  if (!ee(t))
    return !1;
  var e = be(t);
  return e == Ra || e == Ia || e == Aa || e == Sa;
}
var gn = pe["__core-js_shared__"], Or = function() {
  var t = /[^.]+$/.exec(gn && gn.keys && gn.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function _a(t) {
  return !!Or && Or in t;
}
var Oa = Function.prototype, Na = Oa.toString;
function He(t) {
  if (t != null) {
    try {
      return Na.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var Ca = /[\\^$.*+?()[\]{}|]/g, La = /^\[object .+?Constructor\]$/, ya = Function.prototype, va = Object.prototype, Pa = ya.toString, Ma = va.hasOwnProperty, ka = RegExp(
  "^" + Pa.call(Ma).replace(Ca, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function xa(t) {
  if (!ee(t) || _a(t))
    return !1;
  var e = Ne(t) ? ka : La;
  return e.test(He(t));
}
function ba(t, e) {
  return t?.[e];
}
function Ke(t, e) {
  var n = ba(t, e);
  return xa(n) ? n : void 0;
}
var On = Ke(pe, "WeakMap"), Nr = Object.create, wa = /* @__PURE__ */ function() {
  function t() {
  }
  return function(e) {
    if (!ee(e))
      return {};
    if (Nr)
      return Nr(e);
    t.prototype = e;
    var n = new t();
    return t.prototype = void 0, n;
  };
}();
function Ua(t, e, n) {
  switch (n.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, n[0]);
    case 2:
      return t.call(e, n[0], n[1]);
    case 3:
      return t.call(e, n[0], n[1], n[2]);
  }
  return t.apply(e, n);
}
function b() {
}
function Fa(t, e) {
  var n = -1, r = t.length;
  for (e || (e = Array(r)); ++n < r; )
    e[n] = t[n];
  return e;
}
var Da = 800, $a = 16, Ga = Date.now;
function Ba(t) {
  var e = 0, n = 0;
  return function() {
    var r = Ga(), s = $a - (r - n);
    if (n = r, s > 0) {
      if (++e >= Da)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
function Ha(t) {
  return function() {
    return t;
  };
}
var $t = function() {
  try {
    var t = Ke(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
}(), Ka = $t ? function(t, e) {
  return $t(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: Ha(e),
    writable: !0
  });
} : Ye, Wa = Ba(Ka);
function Ns(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length; ++n < r && e(t[n], n, t) !== !1; )
    ;
  return t;
}
function Cs(t, e, n, r) {
  for (var s = t.length, i = n + -1; ++i < s; )
    if (e(t[i], i, t))
      return i;
  return -1;
}
function ja(t) {
  return t !== t;
}
function za(t, e, n) {
  for (var r = n - 1, s = t.length; ++r < s; )
    if (t[r] === e)
      return r;
  return -1;
}
function Kn(t, e, n) {
  return e === e ? za(t, e, n) : Cs(t, ja, n);
}
function Ls(t, e) {
  var n = t == null ? 0 : t.length;
  return !!n && Kn(t, e, 0) > -1;
}
var Va = 9007199254740991, Ya = /^(?:0|[1-9]\d*)$/;
function Jt(t, e) {
  var n = typeof t;
  return e = e ?? Va, !!e && (n == "number" || n != "symbol" && Ya.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
function Wn(t, e, n) {
  e == "__proto__" && $t ? $t(t, e, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : t[e] = n;
}
function gt(t, e) {
  return t === e || t !== t && e !== e;
}
var Xa = Object.prototype, qa = Xa.hasOwnProperty;
function en(t, e, n) {
  var r = t[e];
  (!(qa.call(t, e) && gt(r, n)) || n === void 0 && !(e in t)) && Wn(t, e, n);
}
function jn(t, e, n, r) {
  var s = !n;
  n || (n = {});
  for (var i = -1, a = e.length; ++i < a; ) {
    var o = e[i], c = void 0;
    c === void 0 && (c = t[o]), s ? Wn(n, o, c) : en(n, o, c);
  }
  return n;
}
var Cr = Math.max;
function Za(t, e, n) {
  return e = Cr(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var r = arguments, s = -1, i = Cr(r.length - e, 0), a = Array(i); ++s < i; )
      a[s] = r[e + s];
    s = -1;
    for (var o = Array(e + 1); ++s < e; )
      o[s] = r[s];
    return o[e] = n(a), Ua(t, this, o);
  };
}
function zn(t, e) {
  return Wa(Za(t, e, Ye), t + "");
}
var Qa = 9007199254740991;
function Vn(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= Qa;
}
function Ee(t) {
  return t != null && Vn(t.length) && !Ne(t);
}
function ys(t, e, n) {
  if (!ee(n))
    return !1;
  var r = typeof e;
  return (r == "number" ? Ee(n) && Jt(e, n.length) : r == "string" && e in n) ? gt(n[e], t) : !1;
}
function Ja(t) {
  return zn(function(e, n) {
    var r = -1, s = n.length, i = s > 1 ? n[s - 1] : void 0, a = s > 2 ? n[2] : void 0;
    for (i = t.length > 3 && typeof i == "function" ? (s--, i) : void 0, a && ys(n[0], n[1], a) && (i = s < 3 ? void 0 : i, s = 1), e = Object(e); ++r < s; ) {
      var o = n[r];
      o && t(e, o, r, i);
    }
    return e;
  });
}
var eo = Object.prototype;
function Tt(t) {
  var e = t && t.constructor, n = typeof e == "function" && e.prototype || eo;
  return t === n;
}
function to(t, e) {
  for (var n = -1, r = Array(t); ++n < t; )
    r[n] = e(n);
  return r;
}
var no = "[object Arguments]";
function Lr(t) {
  return oe(t) && be(t) == no;
}
var vs = Object.prototype, ro = vs.hasOwnProperty, so = vs.propertyIsEnumerable, tn = Lr(/* @__PURE__ */ function() {
  return arguments;
}()) ? Lr : function(t) {
  return oe(t) && ro.call(t, "callee") && !so.call(t, "callee");
};
function io() {
  return !1;
}
var Ps = typeof exports == "object" && exports && !exports.nodeType && exports, yr = Ps && typeof module == "object" && module && !module.nodeType && module, ao = yr && yr.exports === Ps, vr = ao ? pe.Buffer : void 0, oo = vr ? vr.isBuffer : void 0, ft = oo || io, co = "[object Arguments]", uo = "[object Array]", lo = "[object Boolean]", ho = "[object Date]", fo = "[object Error]", po = "[object Function]", Eo = "[object Map]", go = "[object Number]", To = "[object Object]", mo = "[object RegExp]", Ao = "[object Set]", Ro = "[object String]", Io = "[object WeakMap]", So = "[object ArrayBuffer]", _o = "[object DataView]", Oo = "[object Float32Array]", No = "[object Float64Array]", Co = "[object Int8Array]", Lo = "[object Int16Array]", yo = "[object Int32Array]", vo = "[object Uint8Array]", Po = "[object Uint8ClampedArray]", Mo = "[object Uint16Array]", ko = "[object Uint32Array]", P = {};
P[Oo] = P[No] = P[Co] = P[Lo] = P[yo] = P[vo] = P[Po] = P[Mo] = P[ko] = !0;
P[co] = P[uo] = P[So] = P[lo] = P[_o] = P[ho] = P[fo] = P[po] = P[Eo] = P[go] = P[To] = P[mo] = P[Ao] = P[Ro] = P[Io] = !1;
function xo(t) {
  return oe(t) && Vn(t.length) && !!P[be(t)];
}
function nn(t) {
  return function(e) {
    return t(e);
  };
}
var Ms = typeof exports == "object" && exports && !exports.nodeType && exports, lt = Ms && typeof module == "object" && module && !module.nodeType && module, bo = lt && lt.exports === Ms, Tn = bo && Ss.process, ke = function() {
  try {
    var t = lt && lt.require && lt.require("util").types;
    return t || Tn && Tn.binding && Tn.binding("util");
  } catch {
  }
}(), Pr = ke && ke.isTypedArray, Yn = Pr ? nn(Pr) : xo, wo = Object.prototype, Uo = wo.hasOwnProperty;
function ks(t, e) {
  var n = N(t), r = !n && tn(t), s = !n && !r && ft(t), i = !n && !r && !s && Yn(t), a = n || r || s || i, o = a ? to(t.length, String) : [], c = o.length;
  for (var u in t)
    (e || Uo.call(t, u)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    s && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    i && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    Jt(u, c))) && o.push(u);
  return o;
}
function xs(t, e) {
  return function(n) {
    return t(e(n));
  };
}
var Fo = xs(Object.keys, Object), Do = Object.prototype, $o = Do.hasOwnProperty;
function bs(t) {
  if (!Tt(t))
    return Fo(t);
  var e = [];
  for (var n in Object(t))
    $o.call(t, n) && n != "constructor" && e.push(n);
  return e;
}
function te(t) {
  return Ee(t) ? ks(t) : bs(t);
}
var Go = Object.prototype, Bo = Go.hasOwnProperty, V = Ja(function(t, e) {
  if (Tt(e) || Ee(e)) {
    jn(e, te(e), t);
    return;
  }
  for (var n in e)
    Bo.call(e, n) && en(t, n, e[n]);
});
function Ho(t) {
  var e = [];
  if (t != null)
    for (var n in Object(t))
      e.push(n);
  return e;
}
var Ko = Object.prototype, Wo = Ko.hasOwnProperty;
function jo(t) {
  if (!ee(t))
    return Ho(t);
  var e = Tt(t), n = [];
  for (var r in t)
    r == "constructor" && (e || !Wo.call(t, r)) || n.push(r);
  return n;
}
function ws(t) {
  return Ee(t) ? ks(t, !0) : jo(t);
}
var zo = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Vo = /^\w*$/;
function Xn(t, e) {
  if (N(t))
    return !1;
  var n = typeof t;
  return n == "number" || n == "symbol" || n == "boolean" || t == null || qt(t) ? !0 : Vo.test(t) || !zo.test(t) || e != null && t in Object(e);
}
var dt = Ke(Object, "create");
function Yo() {
  this.__data__ = dt ? dt(null) : {}, this.size = 0;
}
function Xo(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var qo = "__lodash_hash_undefined__", Zo = Object.prototype, Qo = Zo.hasOwnProperty;
function Jo(t) {
  var e = this.__data__;
  if (dt) {
    var n = e[t];
    return n === qo ? void 0 : n;
  }
  return Qo.call(e, t) ? e[t] : void 0;
}
var ec = Object.prototype, tc = ec.hasOwnProperty;
function nc(t) {
  var e = this.__data__;
  return dt ? e[t] !== void 0 : tc.call(e, t);
}
var rc = "__lodash_hash_undefined__";
function sc(t, e) {
  var n = this.__data__;
  return this.size += this.has(t) ? 0 : 1, n[t] = dt && e === void 0 ? rc : e, this;
}
function $e(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
$e.prototype.clear = Yo;
$e.prototype.delete = Xo;
$e.prototype.get = Jo;
$e.prototype.has = nc;
$e.prototype.set = sc;
function ic() {
  this.__data__ = [], this.size = 0;
}
function rn(t, e) {
  for (var n = t.length; n--; )
    if (gt(t[n][0], e))
      return n;
  return -1;
}
var ac = Array.prototype, oc = ac.splice;
function cc(t) {
  var e = this.__data__, n = rn(e, t);
  if (n < 0)
    return !1;
  var r = e.length - 1;
  return n == r ? e.pop() : oc.call(e, n, 1), --this.size, !0;
}
function uc(t) {
  var e = this.__data__, n = rn(e, t);
  return n < 0 ? void 0 : e[n][1];
}
function lc(t) {
  return rn(this.__data__, t) > -1;
}
function hc(t, e) {
  var n = this.__data__, r = rn(n, t);
  return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this;
}
function Ce(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
Ce.prototype.clear = ic;
Ce.prototype.delete = cc;
Ce.prototype.get = uc;
Ce.prototype.has = lc;
Ce.prototype.set = hc;
var pt = Ke(pe, "Map");
function fc() {
  this.size = 0, this.__data__ = {
    hash: new $e(),
    map: new (pt || Ce)(),
    string: new $e()
  };
}
function dc(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function sn(t, e) {
  var n = t.__data__;
  return dc(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
}
function pc(t) {
  var e = sn(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function Ec(t) {
  return sn(this, t).get(t);
}
function gc(t) {
  return sn(this, t).has(t);
}
function Tc(t, e) {
  var n = sn(this, t), r = n.size;
  return n.set(t, e), this.size += n.size == r ? 0 : 1, this;
}
function Le(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
Le.prototype.clear = fc;
Le.prototype.delete = pc;
Le.prototype.get = Ec;
Le.prototype.has = gc;
Le.prototype.set = Tc;
var mc = "Expected a function";
function qn(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(mc);
  var n = function() {
    var r = arguments, s = e ? e.apply(this, r) : r[0], i = n.cache;
    if (i.has(s))
      return i.get(s);
    var a = t.apply(this, r);
    return n.cache = i.set(s, a) || i, a;
  };
  return n.cache = new (qn.Cache || Le)(), n;
}
qn.Cache = Le;
var Ac = 500;
function Rc(t) {
  var e = qn(t, function(r) {
    return n.size === Ac && n.clear(), r;
  }), n = e.cache;
  return e;
}
var Ic = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Sc = /\\(\\)?/g, _c = Rc(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(Ic, function(n, r, s, i) {
    e.push(s ? i.replace(Sc, "$1") : r || n);
  }), e;
});
function Oc(t) {
  return t == null ? "" : Os(t);
}
function an(t, e) {
  return N(t) ? t : Xn(t, e) ? [t] : _c(Oc(t));
}
function mt(t) {
  if (typeof t == "string" || qt(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
function Zn(t, e) {
  e = an(e, t);
  for (var n = 0, r = e.length; t != null && n < r; )
    t = t[mt(e[n++])];
  return n && n == r ? t : void 0;
}
function Nc(t, e, n) {
  var r = t == null ? void 0 : Zn(t, e);
  return r === void 0 ? n : r;
}
function Qn(t, e) {
  for (var n = -1, r = e.length, s = t.length; ++n < r; )
    t[s + n] = e[n];
  return t;
}
var Mr = J ? J.isConcatSpreadable : void 0;
function Cc(t) {
  return N(t) || tn(t) || !!(Mr && t && t[Mr]);
}
function Jn(t, e, n, r, s) {
  var i = -1, a = t.length;
  for (n || (n = Cc), s || (s = []); ++i < a; ) {
    var o = t[i];
    n(o) ? Qn(s, o) : r || (s[s.length] = o);
  }
  return s;
}
function ie(t) {
  var e = t == null ? 0 : t.length;
  return e ? Jn(t) : [];
}
var Us = xs(Object.getPrototypeOf, Object);
function Fs(t, e, n) {
  var r = -1, s = t.length;
  e < 0 && (e = -e > s ? 0 : s + e), n = n > s ? s : n, n < 0 && (n += s), s = e > n ? 0 : n - e >>> 0, e >>>= 0;
  for (var i = Array(s); ++r < s; )
    i[r] = t[r + e];
  return i;
}
function Lc(t, e, n, r) {
  var s = -1, i = t == null ? 0 : t.length;
  for (r && i && (n = t[++s]); ++s < i; )
    n = e(n, t[s], s, t);
  return n;
}
function yc() {
  this.__data__ = new Ce(), this.size = 0;
}
function vc(t) {
  var e = this.__data__, n = e.delete(t);
  return this.size = e.size, n;
}
function Pc(t) {
  return this.__data__.get(t);
}
function Mc(t) {
  return this.__data__.has(t);
}
var kc = 200;
function xc(t, e) {
  var n = this.__data__;
  if (n instanceof Ce) {
    var r = n.__data__;
    if (!pt || r.length < kc - 1)
      return r.push([t, e]), this.size = ++n.size, this;
    n = this.__data__ = new Le(r);
  }
  return n.set(t, e), this.size = n.size, this;
}
function de(t) {
  var e = this.__data__ = new Ce(t);
  this.size = e.size;
}
de.prototype.clear = yc;
de.prototype.delete = vc;
de.prototype.get = Pc;
de.prototype.has = Mc;
de.prototype.set = xc;
function bc(t, e) {
  return t && jn(e, te(e), t);
}
var Ds = typeof exports == "object" && exports && !exports.nodeType && exports, kr = Ds && typeof module == "object" && module && !module.nodeType && module, wc = kr && kr.exports === Ds, xr = wc ? pe.Buffer : void 0, br = xr ? xr.allocUnsafe : void 0;
function Uc(t, e) {
  var n = t.length, r = br ? br(n) : new t.constructor(n);
  return t.copy(r), r;
}
function er(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length, s = 0, i = []; ++n < r; ) {
    var a = t[n];
    e(a, n, t) && (i[s++] = a);
  }
  return i;
}
function $s() {
  return [];
}
var Fc = Object.prototype, Dc = Fc.propertyIsEnumerable, wr = Object.getOwnPropertySymbols, tr = wr ? function(t) {
  return t == null ? [] : (t = Object(t), er(wr(t), function(e) {
    return Dc.call(t, e);
  }));
} : $s;
function $c(t, e) {
  return jn(t, tr(t), e);
}
var Gc = Object.getOwnPropertySymbols, Bc = Gc ? function(t) {
  for (var e = []; t; )
    Qn(e, tr(t)), t = Us(t);
  return e;
} : $s;
function Gs(t, e, n) {
  var r = e(t);
  return N(t) ? r : Qn(r, n(t));
}
function Nn(t) {
  return Gs(t, te, tr);
}
function Hc(t) {
  return Gs(t, ws, Bc);
}
var Cn = Ke(pe, "DataView"), Ln = Ke(pe, "Promise"), Ve = Ke(pe, "Set"), Ur = "[object Map]", Kc = "[object Object]", Fr = "[object Promise]", Dr = "[object Set]", $r = "[object WeakMap]", Gr = "[object DataView]", Wc = He(Cn), jc = He(pt), zc = He(Ln), Vc = He(Ve), Yc = He(On), Z = be;
(Cn && Z(new Cn(new ArrayBuffer(1))) != Gr || pt && Z(new pt()) != Ur || Ln && Z(Ln.resolve()) != Fr || Ve && Z(new Ve()) != Dr || On && Z(new On()) != $r) && (Z = function(t) {
  var e = be(t), n = e == Kc ? t.constructor : void 0, r = n ? He(n) : "";
  if (r)
    switch (r) {
      case Wc:
        return Gr;
      case jc:
        return Ur;
      case zc:
        return Fr;
      case Vc:
        return Dr;
      case Yc:
        return $r;
    }
  return e;
});
var Xc = Object.prototype, qc = Xc.hasOwnProperty;
function Zc(t) {
  var e = t.length, n = new t.constructor(e);
  return e && typeof t[0] == "string" && qc.call(t, "index") && (n.index = t.index, n.input = t.input), n;
}
var Gt = pe.Uint8Array;
function Qc(t) {
  var e = new t.constructor(t.byteLength);
  return new Gt(e).set(new Gt(t)), e;
}
function Jc(t, e) {
  var n = t.buffer;
  return new t.constructor(n, t.byteOffset, t.byteLength);
}
var eu = /\w*$/;
function tu(t) {
  var e = new t.constructor(t.source, eu.exec(t));
  return e.lastIndex = t.lastIndex, e;
}
var Br = J ? J.prototype : void 0, Hr = Br ? Br.valueOf : void 0;
function nu(t) {
  return Hr ? Object(Hr.call(t)) : {};
}
function ru(t, e) {
  var n = t.buffer;
  return new t.constructor(n, t.byteOffset, t.length);
}
var su = "[object Boolean]", iu = "[object Date]", au = "[object Map]", ou = "[object Number]", cu = "[object RegExp]", uu = "[object Set]", lu = "[object String]", hu = "[object Symbol]", fu = "[object ArrayBuffer]", du = "[object DataView]", pu = "[object Float32Array]", Eu = "[object Float64Array]", gu = "[object Int8Array]", Tu = "[object Int16Array]", mu = "[object Int32Array]", Au = "[object Uint8Array]", Ru = "[object Uint8ClampedArray]", Iu = "[object Uint16Array]", Su = "[object Uint32Array]";
function _u(t, e, n) {
  var r = t.constructor;
  switch (e) {
    case fu:
      return Qc(t);
    case su:
    case iu:
      return new r(+t);
    case du:
      return Jc(t);
    case pu:
    case Eu:
    case gu:
    case Tu:
    case mu:
    case Au:
    case Ru:
    case Iu:
    case Su:
      return ru(t);
    case au:
      return new r();
    case ou:
    case lu:
      return new r(t);
    case cu:
      return tu(t);
    case uu:
      return new r();
    case hu:
      return nu(t);
  }
}
function Ou(t) {
  return typeof t.constructor == "function" && !Tt(t) ? wa(Us(t)) : {};
}
var Nu = "[object Map]";
function Cu(t) {
  return oe(t) && Z(t) == Nu;
}
var Kr = ke && ke.isMap, Lu = Kr ? nn(Kr) : Cu, yu = "[object Set]";
function vu(t) {
  return oe(t) && Z(t) == yu;
}
var Wr = ke && ke.isSet, Pu = Wr ? nn(Wr) : vu, Bs = "[object Arguments]", Mu = "[object Array]", ku = "[object Boolean]", xu = "[object Date]", bu = "[object Error]", Hs = "[object Function]", wu = "[object GeneratorFunction]", Uu = "[object Map]", Fu = "[object Number]", Ks = "[object Object]", Du = "[object RegExp]", $u = "[object Set]", Gu = "[object String]", Bu = "[object Symbol]", Hu = "[object WeakMap]", Ku = "[object ArrayBuffer]", Wu = "[object DataView]", ju = "[object Float32Array]", zu = "[object Float64Array]", Vu = "[object Int8Array]", Yu = "[object Int16Array]", Xu = "[object Int32Array]", qu = "[object Uint8Array]", Zu = "[object Uint8ClampedArray]", Qu = "[object Uint16Array]", Ju = "[object Uint32Array]", y = {};
y[Bs] = y[Mu] = y[Ku] = y[Wu] = y[ku] = y[xu] = y[ju] = y[zu] = y[Vu] = y[Yu] = y[Xu] = y[Uu] = y[Fu] = y[Ks] = y[Du] = y[$u] = y[Gu] = y[Bu] = y[qu] = y[Zu] = y[Qu] = y[Ju] = !0;
y[bu] = y[Hs] = y[Hu] = !1;
function kt(t, e, n, r, s, i) {
  var a;
  if (a !== void 0)
    return a;
  if (!ee(t))
    return t;
  var o = N(t);
  if (o)
    return a = Zc(t), Fa(t, a);
  var c = Z(t), u = c == Hs || c == wu;
  if (ft(t))
    return Uc(t);
  if (c == Ks || c == Bs || u && !s)
    return a = u ? {} : Ou(t), $c(t, bc(a, t));
  if (!y[c])
    return s ? t : {};
  a = _u(t, c), i || (i = new de());
  var l = i.get(t);
  if (l)
    return l;
  i.set(t, a), Pu(t) ? t.forEach(function(p) {
    a.add(kt(p, e, n, p, t, i));
  }) : Lu(t) && t.forEach(function(p, T) {
    a.set(T, kt(p, e, n, T, t, i));
  });
  var h = Nn, f = o ? void 0 : h(t);
  return Ns(f || t, function(p, T) {
    f && (T = p, p = t[T]), en(a, T, kt(p, e, n, T, t, i));
  }), a;
}
var el = 4;
function D(t) {
  return kt(t, el);
}
function At(t) {
  for (var e = -1, n = t == null ? 0 : t.length, r = 0, s = []; ++e < n; ) {
    var i = t[e];
    i && (s[r++] = i);
  }
  return s;
}
var tl = "__lodash_hash_undefined__";
function nl(t) {
  return this.__data__.set(t, tl), this;
}
function rl(t) {
  return this.__data__.has(t);
}
function Xe(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.__data__ = new Le(); ++e < n; )
    this.add(t[e]);
}
Xe.prototype.add = Xe.prototype.push = nl;
Xe.prototype.has = rl;
function Ws(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length; ++n < r; )
    if (e(t[n], n, t))
      return !0;
  return !1;
}
function nr(t, e) {
  return t.has(e);
}
var sl = 1, il = 2;
function js(t, e, n, r, s, i) {
  var a = n & sl, o = t.length, c = e.length;
  if (o != c && !(a && c > o))
    return !1;
  var u = i.get(t), l = i.get(e);
  if (u && l)
    return u == e && l == t;
  var h = -1, f = !0, p = n & il ? new Xe() : void 0;
  for (i.set(t, e), i.set(e, t); ++h < o; ) {
    var T = t[h], I = e[h];
    if (r)
      var O = a ? r(I, T, h, e, t, i) : r(T, I, h, t, e, i);
    if (O !== void 0) {
      if (O)
        continue;
      f = !1;
      break;
    }
    if (p) {
      if (!Ws(e, function(g, E) {
        if (!nr(p, E) && (T === g || s(T, g, n, r, i)))
          return p.push(E);
      })) {
        f = !1;
        break;
      }
    } else if (!(T === I || s(T, I, n, r, i))) {
      f = !1;
      break;
    }
  }
  return i.delete(t), i.delete(e), f;
}
function al(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(r, s) {
    n[++e] = [s, r];
  }), n;
}
function rr(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(r) {
    n[++e] = r;
  }), n;
}
var ol = 1, cl = 2, ul = "[object Boolean]", ll = "[object Date]", hl = "[object Error]", fl = "[object Map]", dl = "[object Number]", pl = "[object RegExp]", El = "[object Set]", gl = "[object String]", Tl = "[object Symbol]", ml = "[object ArrayBuffer]", Al = "[object DataView]", jr = J ? J.prototype : void 0, mn = jr ? jr.valueOf : void 0;
function Rl(t, e, n, r, s, i, a) {
  switch (n) {
    case Al:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case ml:
      return !(t.byteLength != e.byteLength || !i(new Gt(t), new Gt(e)));
    case ul:
    case ll:
    case dl:
      return gt(+t, +e);
    case hl:
      return t.name == e.name && t.message == e.message;
    case pl:
    case gl:
      return t == e + "";
    case fl:
      var o = al;
    case El:
      var c = r & ol;
      if (o || (o = rr), t.size != e.size && !c)
        return !1;
      var u = a.get(t);
      if (u)
        return u == e;
      r |= cl, a.set(t, e);
      var l = js(o(t), o(e), r, s, i, a);
      return a.delete(t), l;
    case Tl:
      if (mn)
        return mn.call(t) == mn.call(e);
  }
  return !1;
}
var Il = 1, Sl = Object.prototype, _l = Sl.hasOwnProperty;
function Ol(t, e, n, r, s, i) {
  var a = n & Il, o = Nn(t), c = o.length, u = Nn(e), l = u.length;
  if (c != l && !a)
    return !1;
  for (var h = c; h--; ) {
    var f = o[h];
    if (!(a ? f in e : _l.call(e, f)))
      return !1;
  }
  var p = i.get(t), T = i.get(e);
  if (p && T)
    return p == e && T == t;
  var I = !0;
  i.set(t, e), i.set(e, t);
  for (var O = a; ++h < c; ) {
    f = o[h];
    var g = t[f], E = e[f];
    if (r)
      var d = a ? r(E, g, f, e, t, i) : r(g, E, f, t, e, i);
    if (!(d === void 0 ? g === E || s(g, E, n, r, i) : d)) {
      I = !1;
      break;
    }
    O || (O = f == "constructor");
  }
  if (I && !O) {
    var m = t.constructor, L = e.constructor;
    m != L && "constructor" in t && "constructor" in e && !(typeof m == "function" && m instanceof m && typeof L == "function" && L instanceof L) && (I = !1);
  }
  return i.delete(t), i.delete(e), I;
}
var Nl = 1, zr = "[object Arguments]", Vr = "[object Array]", Ct = "[object Object]", Cl = Object.prototype, Yr = Cl.hasOwnProperty;
function Ll(t, e, n, r, s, i) {
  var a = N(t), o = N(e), c = a ? Vr : Z(t), u = o ? Vr : Z(e);
  c = c == zr ? Ct : c, u = u == zr ? Ct : u;
  var l = c == Ct, h = u == Ct, f = c == u;
  if (f && ft(t)) {
    if (!ft(e))
      return !1;
    a = !0, l = !1;
  }
  if (f && !l)
    return i || (i = new de()), a || Yn(t) ? js(t, e, n, r, s, i) : Rl(t, e, c, n, r, s, i);
  if (!(n & Nl)) {
    var p = l && Yr.call(t, "__wrapped__"), T = h && Yr.call(e, "__wrapped__");
    if (p || T) {
      var I = p ? t.value() : t, O = T ? e.value() : e;
      return i || (i = new de()), s(I, O, n, r, i);
    }
  }
  return f ? (i || (i = new de()), Ol(t, e, n, r, s, i)) : !1;
}
function sr(t, e, n, r, s) {
  return t === e ? !0 : t == null || e == null || !oe(t) && !oe(e) ? t !== t && e !== e : Ll(t, e, n, r, sr, s);
}
var yl = 1, vl = 2;
function Pl(t, e, n, r) {
  var s = n.length, i = s;
  if (t == null)
    return !i;
  for (t = Object(t); s--; ) {
    var a = n[s];
    if (a[2] ? a[1] !== t[a[0]] : !(a[0] in t))
      return !1;
  }
  for (; ++s < i; ) {
    a = n[s];
    var o = a[0], c = t[o], u = a[1];
    if (a[2]) {
      if (c === void 0 && !(o in t))
        return !1;
    } else {
      var l = new de(), h;
      if (!(h === void 0 ? sr(u, c, yl | vl, r, l) : h))
        return !1;
    }
  }
  return !0;
}
function zs(t) {
  return t === t && !ee(t);
}
function Ml(t) {
  for (var e = te(t), n = e.length; n--; ) {
    var r = e[n], s = t[r];
    e[n] = [r, s, zs(s)];
  }
  return e;
}
function Vs(t, e) {
  return function(n) {
    return n == null ? !1 : n[t] === e && (e !== void 0 || t in Object(n));
  };
}
function kl(t) {
  var e = Ml(t);
  return e.length == 1 && e[0][2] ? Vs(e[0][0], e[0][1]) : function(n) {
    return n === t || Pl(n, t, e);
  };
}
function xl(t, e) {
  return t != null && e in Object(t);
}
function Ys(t, e, n) {
  e = an(e, t);
  for (var r = -1, s = e.length, i = !1; ++r < s; ) {
    var a = mt(e[r]);
    if (!(i = t != null && n(t, a)))
      break;
    t = t[a];
  }
  return i || ++r != s ? i : (s = t == null ? 0 : t.length, !!s && Vn(s) && Jt(a, s) && (N(t) || tn(t)));
}
function bl(t, e) {
  return t != null && Ys(t, e, xl);
}
var wl = 1, Ul = 2;
function Fl(t, e) {
  return Xn(t) && zs(e) ? Vs(mt(t), e) : function(n) {
    var r = Nc(n, t);
    return r === void 0 && r === e ? bl(n, t) : sr(e, r, wl | Ul);
  };
}
function Dl(t) {
  return function(e) {
    return e?.[t];
  };
}
function $l(t) {
  return function(e) {
    return Zn(e, t);
  };
}
function Gl(t) {
  return Xn(t) ? Dl(mt(t)) : $l(t);
}
function ge(t) {
  return typeof t == "function" ? t : t == null ? Ye : typeof t == "object" ? N(t) ? Fl(t[0], t[1]) : kl(t) : Gl(t);
}
function Bl(t, e, n, r) {
  for (var s = -1, i = t == null ? 0 : t.length; ++s < i; ) {
    var a = t[s];
    e(r, a, n(a), t);
  }
  return r;
}
function Hl(t) {
  return function(e, n, r) {
    for (var s = -1, i = Object(e), a = r(e), o = a.length; o--; ) {
      var c = a[++s];
      if (n(i[c], c, i) === !1)
        break;
    }
    return e;
  };
}
var Kl = Hl();
function Wl(t, e) {
  return t && Kl(t, e, te);
}
function jl(t, e) {
  return function(n, r) {
    if (n == null)
      return n;
    if (!Ee(n))
      return t(n, r);
    for (var s = n.length, i = -1, a = Object(n); ++i < s && r(a[i], i, a) !== !1; )
      ;
    return n;
  };
}
var We = jl(Wl);
function zl(t, e, n, r) {
  return We(t, function(s, i, a) {
    e(r, s, n(s), a);
  }), r;
}
function Vl(t, e) {
  return function(n, r) {
    var s = N(n) ? Bl : zl, i = e ? e() : {};
    return s(n, t, ge(r), i);
  };
}
var Xs = Object.prototype, Yl = Xs.hasOwnProperty, ir = zn(function(t, e) {
  t = Object(t);
  var n = -1, r = e.length, s = r > 2 ? e[2] : void 0;
  for (s && ys(e[0], e[1], s) && (r = 1); ++n < r; )
    for (var i = e[n], a = ws(i), o = -1, c = a.length; ++o < c; ) {
      var u = a[o], l = t[u];
      (l === void 0 || gt(l, Xs[u]) && !Yl.call(t, u)) && (t[u] = i[u]);
    }
  return t;
});
function Xr(t) {
  return oe(t) && Ee(t);
}
var Xl = 200;
function ql(t, e, n, r) {
  var s = -1, i = Ls, a = !0, o = t.length, c = [], u = e.length;
  if (!o)
    return c;
  e.length >= Xl && (i = nr, a = !1, e = new Xe(e));
  e:
    for (; ++s < o; ) {
      var l = t[s], h = l;
      if (l = l !== 0 ? l : 0, a && h === h) {
        for (var f = u; f--; )
          if (e[f] === h)
            continue e;
        c.push(l);
      } else i(e, h, r) || c.push(l);
    }
  return c;
}
var on = zn(function(t, e) {
  return Xr(t) ? ql(t, Jn(e, 1, Xr, !0)) : [];
});
function qe(t) {
  var e = t == null ? 0 : t.length;
  return e ? t[e - 1] : void 0;
}
function F(t, e, n) {
  var r = t == null ? 0 : t.length;
  return r ? (e = e === void 0 ? 1 : Qt(e), Fs(t, e < 0 ? 0 : e, r)) : [];
}
function Et(t, e, n) {
  var r = t == null ? 0 : t.length;
  return r ? (e = e === void 0 ? 1 : Qt(e), e = r - e, Fs(t, 0, e < 0 ? 0 : e)) : [];
}
function Zl(t) {
  return typeof t == "function" ? t : Ye;
}
function S(t, e) {
  var n = N(t) ? Ns : We;
  return n(t, Zl(e));
}
function Ql(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length; ++n < r; )
    if (!e(t[n], n, t))
      return !1;
  return !0;
}
function Jl(t, e) {
  var n = !0;
  return We(t, function(r, s, i) {
    return n = !!e(r, s, i), n;
  }), n;
}
function ae(t, e, n) {
  var r = N(t) ? Ql : Jl;
  return r(t, ge(e));
}
function qs(t, e) {
  var n = [];
  return We(t, function(r, s, i) {
    e(r, s, i) && n.push(r);
  }), n;
}
function ne(t, e) {
  var n = N(t) ? er : qs;
  return n(t, ge(e));
}
function eh(t) {
  return function(e, n, r) {
    var s = Object(e);
    if (!Ee(e)) {
      var i = ge(n);
      e = te(e), n = function(o) {
        return i(s[o], o, s);
      };
    }
    var a = t(e, n, r);
    return a > -1 ? s[i ? e[a] : a] : void 0;
  };
}
var th = Math.max;
function nh(t, e, n) {
  var r = t == null ? 0 : t.length;
  if (!r)
    return -1;
  var s = n == null ? 0 : Qt(n);
  return s < 0 && (s = th(r + s, 0)), Cs(t, ge(e), s);
}
var Ze = eh(nh);
function ce(t) {
  return t && t.length ? t[0] : void 0;
}
function rh(t, e) {
  var n = -1, r = Ee(t) ? Array(t.length) : [];
  return We(t, function(s, i, a) {
    r[++n] = e(s, i, a);
  }), r;
}
function A(t, e) {
  var n = N(t) ? Zt : rh;
  return n(t, ge(e));
}
function Q(t, e) {
  return Jn(A(t, e));
}
var sh = Object.prototype, ih = sh.hasOwnProperty, ah = Vl(function(t, e, n) {
  ih.call(t, n) ? t[n].push(e) : Wn(t, n, [e]);
}), oh = Object.prototype, ch = oh.hasOwnProperty;
function uh(t, e) {
  return t != null && ch.call(t, e);
}
function R(t, e) {
  return t != null && Ys(t, e, uh);
}
var lh = "[object String]";
function W(t) {
  return typeof t == "string" || !N(t) && oe(t) && be(t) == lh;
}
function hh(t, e) {
  return Zt(e, function(n) {
    return t[n];
  });
}
function w(t) {
  return t == null ? [] : hh(t, te(t));
}
var fh = Math.max;
function H(t, e, n, r) {
  t = Ee(t) ? t : w(t), n = n ? Qt(n) : 0;
  var s = t.length;
  return n < 0 && (n = fh(s + n, 0)), W(t) ? n <= s && t.indexOf(e, n) > -1 : !!s && Kn(t, e, n) > -1;
}
function qr(t, e, n) {
  var r = t == null ? 0 : t.length;
  if (!r)
    return -1;
  var s = 0;
  return Kn(t, e, s);
}
var dh = "[object Map]", ph = "[object Set]", Eh = Object.prototype, gh = Eh.hasOwnProperty;
function v(t) {
  if (t == null)
    return !0;
  if (Ee(t) && (N(t) || typeof t == "string" || typeof t.splice == "function" || ft(t) || Yn(t) || tn(t)))
    return !t.length;
  var e = Z(t);
  if (e == dh || e == ph)
    return !t.size;
  if (Tt(t))
    return !bs(t).length;
  for (var n in t)
    if (gh.call(t, n))
      return !1;
  return !0;
}
var Th = "[object RegExp]";
function mh(t) {
  return oe(t) && be(t) == Th;
}
var Zr = ke && ke.isRegExp, Se = Zr ? nn(Zr) : mh;
function _e(t) {
  return t === void 0;
}
var Ah = "Expected a function";
function Rh(t) {
  if (typeof t != "function")
    throw new TypeError(Ah);
  return function() {
    var e = arguments;
    switch (e.length) {
      case 0:
        return !t.call(this);
      case 1:
        return !t.call(this, e[0]);
      case 2:
        return !t.call(this, e[0], e[1]);
      case 3:
        return !t.call(this, e[0], e[1], e[2]);
    }
    return !t.apply(this, e);
  };
}
function Ih(t, e, n, r) {
  if (!ee(t))
    return t;
  e = an(e, t);
  for (var s = -1, i = e.length, a = i - 1, o = t; o != null && ++s < i; ) {
    var c = mt(e[s]), u = n;
    if (c === "__proto__" || c === "constructor" || c === "prototype")
      return t;
    if (s != a) {
      var l = o[c];
      u = void 0, u === void 0 && (u = ee(l) ? l : Jt(e[s + 1]) ? [] : {});
    }
    en(o, c, u), o = o[c];
  }
  return t;
}
function Sh(t, e, n) {
  for (var r = -1, s = e.length, i = {}; ++r < s; ) {
    var a = e[r], o = Zn(t, a);
    n(o, a) && Ih(i, an(a, t), o);
  }
  return i;
}
function ue(t, e) {
  if (t == null)
    return {};
  var n = Zt(Hc(t), function(r) {
    return [r];
  });
  return e = ge(e), Sh(t, n, function(r, s) {
    return e(r, s[0]);
  });
}
function _h(t, e, n, r, s) {
  return s(t, function(i, a, o) {
    n = r ? (r = !1, i) : e(n, i, a, o);
  }), n;
}
function Y(t, e, n) {
  var r = N(t) ? Lc : _h, s = arguments.length < 3;
  return r(t, ge(e), n, s, We);
}
function cn(t, e) {
  var n = N(t) ? er : qs;
  return n(t, Rh(ge(e)));
}
function Oh(t, e) {
  var n;
  return We(t, function(r, s, i) {
    return n = e(r, s, i), !n;
  }), !!n;
}
function Zs(t, e, n) {
  var r = N(t) ? Ws : Oh;
  return r(t, ge(e));
}
var Nh = 1 / 0, Ch = Ve && 1 / rr(new Ve([, -0]))[1] == Nh ? function(t) {
  return new Ve(t);
} : b, Lh = 200;
function yh(t, e, n) {
  var r = -1, s = Ls, i = t.length, a = !0, o = [], c = o;
  if (i >= Lh) {
    var u = Ch(t);
    if (u)
      return rr(u);
    a = !1, s = nr, c = new Xe();
  } else
    c = o;
  e:
    for (; ++r < i; ) {
      var l = t[r], h = l;
      if (l = l !== 0 ? l : 0, a && h === h) {
        for (var f = c.length; f--; )
          if (c[f] === h)
            continue e;
        o.push(l);
      } else s(c, h, n) || (c !== o && c.push(h), o.push(l));
    }
  return o;
}
function ar(t) {
  return t && t.length ? yh(t) : [];
}
function yn(t) {
  console && console.error && console.error(`Error: ${t}`);
}
function Qs(t) {
  console && console.warn && console.warn(`Warning: ${t}`);
}
function Js(t) {
  const e = (/* @__PURE__ */ new Date()).getTime(), n = t();
  return { time: (/* @__PURE__ */ new Date()).getTime() - e, value: n };
}
function ei(t) {
  function e() {
  }
  e.prototype = t;
  const n = new e();
  function r() {
    return typeof n.bar;
  }
  return r(), r(), t;
}
function vh(t) {
  return Ph(t) ? t.LABEL : t.name;
}
function Ph(t) {
  return W(t.LABEL) && t.LABEL !== "";
}
class Te {
  get definition() {
    return this._definition;
  }
  set definition(e) {
    this._definition = e;
  }
  constructor(e) {
    this._definition = e;
  }
  accept(e) {
    e.visit(this), S(this.definition, (n) => {
      n.accept(e);
    });
  }
}
class X extends Te {
  constructor(e) {
    super([]), this.idx = 1, V(this, ue(e, (n) => n !== void 0));
  }
  set definition(e) {
  }
  get definition() {
    return this.referencedRule !== void 0 ? this.referencedRule.definition : [];
  }
  accept(e) {
    e.visit(this);
  }
}
class Qe extends Te {
  constructor(e) {
    super(e.definition), this.orgText = "", V(this, ue(e, (n) => n !== void 0));
  }
}
class j extends Te {
  constructor(e) {
    super(e.definition), this.ignoreAmbiguities = !1, V(this, ue(e, (n) => n !== void 0));
  }
}
class K extends Te {
  constructor(e) {
    super(e.definition), this.idx = 1, V(this, ue(e, (n) => n !== void 0));
  }
}
class me extends Te {
  constructor(e) {
    super(e.definition), this.idx = 1, V(this, ue(e, (n) => n !== void 0));
  }
}
class Ae extends Te {
  constructor(e) {
    super(e.definition), this.idx = 1, V(this, ue(e, (n) => n !== void 0));
  }
}
class U extends Te {
  constructor(e) {
    super(e.definition), this.idx = 1, V(this, ue(e, (n) => n !== void 0));
  }
}
class le extends Te {
  constructor(e) {
    super(e.definition), this.idx = 1, V(this, ue(e, (n) => n !== void 0));
  }
}
class he extends Te {
  get definition() {
    return this._definition;
  }
  set definition(e) {
    this._definition = e;
  }
  constructor(e) {
    super(e.definition), this.idx = 1, this.ignoreAmbiguities = !1, this.hasPredicates = !1, V(this, ue(e, (n) => n !== void 0));
  }
}
class M {
  constructor(e) {
    this.idx = 1, V(this, ue(e, (n) => n !== void 0));
  }
  accept(e) {
    e.visit(this);
  }
}
function Mh(t) {
  return A(t, xt);
}
function xt(t) {
  function e(n) {
    return A(n, xt);
  }
  if (t instanceof X) {
    const n = {
      type: "NonTerminal",
      name: t.nonTerminalName,
      idx: t.idx
    };
    return W(t.label) && (n.label = t.label), n;
  } else {
    if (t instanceof j)
      return {
        type: "Alternative",
        definition: e(t.definition)
      };
    if (t instanceof K)
      return {
        type: "Option",
        idx: t.idx,
        definition: e(t.definition)
      };
    if (t instanceof me)
      return {
        type: "RepetitionMandatory",
        idx: t.idx,
        definition: e(t.definition)
      };
    if (t instanceof Ae)
      return {
        type: "RepetitionMandatoryWithSeparator",
        idx: t.idx,
        separator: xt(new M({ terminalType: t.separator })),
        definition: e(t.definition)
      };
    if (t instanceof le)
      return {
        type: "RepetitionWithSeparator",
        idx: t.idx,
        separator: xt(new M({ terminalType: t.separator })),
        definition: e(t.definition)
      };
    if (t instanceof U)
      return {
        type: "Repetition",
        idx: t.idx,
        definition: e(t.definition)
      };
    if (t instanceof he)
      return {
        type: "Alternation",
        idx: t.idx,
        definition: e(t.definition)
      };
    if (t instanceof M) {
      const n = {
        type: "Terminal",
        name: t.terminalType.name,
        label: vh(t.terminalType),
        idx: t.idx
      };
      W(t.label) && (n.terminalLabel = t.label);
      const r = t.terminalType.PATTERN;
      return t.terminalType.PATTERN && (n.pattern = Se(r) ? r.source : r), n;
    } else {
      if (t instanceof Qe)
        return {
          type: "Rule",
          name: t.name,
          orgText: t.orgText,
          definition: e(t.definition)
        };
      throw Error("non exhaustive match");
    }
  }
}
class Je {
  visit(e) {
    const n = e;
    switch (n.constructor) {
      case X:
        return this.visitNonTerminal(n);
      case j:
        return this.visitAlternative(n);
      case K:
        return this.visitOption(n);
      case me:
        return this.visitRepetitionMandatory(n);
      case Ae:
        return this.visitRepetitionMandatoryWithSeparator(n);
      case le:
        return this.visitRepetitionWithSeparator(n);
      case U:
        return this.visitRepetition(n);
      case he:
        return this.visitAlternation(n);
      case M:
        return this.visitTerminal(n);
      case Qe:
        return this.visitRule(n);
      /* c8 ignore next 2 */
      default:
        throw Error("non exhaustive match");
    }
  }
  /* c8 ignore next */
  visitNonTerminal(e) {
  }
  /* c8 ignore next */
  visitAlternative(e) {
  }
  /* c8 ignore next */
  visitOption(e) {
  }
  /* c8 ignore next */
  visitRepetition(e) {
  }
  /* c8 ignore next */
  visitRepetitionMandatory(e) {
  }
  /* c8 ignore next 3 */
  visitRepetitionMandatoryWithSeparator(e) {
  }
  /* c8 ignore next */
  visitRepetitionWithSeparator(e) {
  }
  /* c8 ignore next */
  visitAlternation(e) {
  }
  /* c8 ignore next */
  visitTerminal(e) {
  }
  /* c8 ignore next */
  visitRule(e) {
  }
}
function kh(t) {
  return t instanceof j || t instanceof K || t instanceof U || t instanceof me || t instanceof Ae || t instanceof le || t instanceof M || t instanceof Qe;
}
function Bt(t, e = []) {
  return t instanceof K || t instanceof U || t instanceof le ? !0 : t instanceof he ? Zs(t.definition, (r) => Bt(r, e)) : t instanceof X && H(e, t) ? !1 : t instanceof Te ? (t instanceof X && e.push(t), ae(t.definition, (r) => Bt(r, e))) : !1;
}
function xh(t) {
  return t instanceof he;
}
function fe(t) {
  if (t instanceof X)
    return "SUBRULE";
  if (t instanceof K)
    return "OPTION";
  if (t instanceof he)
    return "OR";
  if (t instanceof me)
    return "AT_LEAST_ONE";
  if (t instanceof Ae)
    return "AT_LEAST_ONE_SEP";
  if (t instanceof le)
    return "MANY_SEP";
  if (t instanceof U)
    return "MANY";
  if (t instanceof M)
    return "CONSUME";
  throw Error("non exhaustive match");
}
class un {
  walk(e, n = []) {
    S(e.definition, (r, s) => {
      const i = F(e.definition, s + 1);
      if (r instanceof X)
        this.walkProdRef(r, i, n);
      else if (r instanceof M)
        this.walkTerminal(r, i, n);
      else if (r instanceof j)
        this.walkFlat(r, i, n);
      else if (r instanceof K)
        this.walkOption(r, i, n);
      else if (r instanceof me)
        this.walkAtLeastOne(r, i, n);
      else if (r instanceof Ae)
        this.walkAtLeastOneSep(r, i, n);
      else if (r instanceof le)
        this.walkManySep(r, i, n);
      else if (r instanceof U)
        this.walkMany(r, i, n);
      else if (r instanceof he)
        this.walkOr(r, i, n);
      else
        throw Error("non exhaustive match");
    });
  }
  walkTerminal(e, n, r) {
  }
  walkProdRef(e, n, r) {
  }
  walkFlat(e, n, r) {
    const s = n.concat(r);
    this.walk(e, s);
  }
  walkOption(e, n, r) {
    const s = n.concat(r);
    this.walk(e, s);
  }
  walkAtLeastOne(e, n, r) {
    const s = [
      new K({ definition: e.definition })
    ].concat(n, r);
    this.walk(e, s);
  }
  walkAtLeastOneSep(e, n, r) {
    const s = Qr(e, n, r);
    this.walk(e, s);
  }
  walkMany(e, n, r) {
    const s = [
      new K({ definition: e.definition })
    ].concat(n, r);
    this.walk(e, s);
  }
  walkManySep(e, n, r) {
    const s = Qr(e, n, r);
    this.walk(e, s);
  }
  walkOr(e, n, r) {
    const s = n.concat(r);
    S(e.definition, (i) => {
      const a = new j({ definition: [i] });
      this.walk(a, s);
    });
  }
}
function Qr(t, e, n) {
  return [
    new K({
      definition: [
        new M({ terminalType: t.separator })
      ].concat(t.definition)
    })
  ].concat(e, n);
}
function Rt(t) {
  if (t instanceof X)
    return Rt(t.referencedRule);
  if (t instanceof M)
    return Uh(t);
  if (kh(t))
    return bh(t);
  if (xh(t))
    return wh(t);
  throw Error("non exhaustive match");
}
function bh(t) {
  let e = [];
  const n = t.definition;
  let r = 0, s = n.length > r, i, a = !0;
  for (; s && a; )
    i = n[r], a = Bt(i), e = e.concat(Rt(i)), r = r + 1, s = n.length > r;
  return ar(e);
}
function wh(t) {
  const e = A(t.definition, (n) => Rt(n));
  return ar(ie(e));
}
function Uh(t) {
  return [t.terminalType];
}
const ti = "_~IN~_";
class Fh extends un {
  constructor(e) {
    super(), this.topProd = e, this.follows = {};
  }
  startWalking() {
    return this.walk(this.topProd), this.follows;
  }
  walkTerminal(e, n, r) {
  }
  walkProdRef(e, n, r) {
    const s = $h(e.referencedRule, e.idx) + this.topProd.name, i = n.concat(r), a = new j({ definition: i }), o = Rt(a);
    this.follows[s] = o;
  }
}
function Dh(t) {
  const e = {};
  return S(t, (n) => {
    const r = new Fh(n).startWalking();
    V(e, r);
  }), e;
}
function $h(t, e) {
  return t.name + e + ti;
}
function _(t) {
  return t.charCodeAt(0);
}
function An(t, e) {
  Array.isArray(t) ? t.forEach(function(n) {
    e.push(n);
  }) : e.push(t);
}
function it(t, e) {
  if (t[e] === !0)
    throw "duplicate flag " + e;
  t[e], t[e] = !0;
}
function ze(t) {
  if (t === void 0)
    throw Error("Internal Error - Should never get here!");
  return !0;
}
function Gh() {
  throw Error("Internal Error - Should never get here!");
}
function Jr(t) {
  return t.type === "Character";
}
const Ht = [];
for (let t = _("0"); t <= _("9"); t++)
  Ht.push(t);
const Kt = [_("_")].concat(Ht);
for (let t = _("a"); t <= _("z"); t++)
  Kt.push(t);
for (let t = _("A"); t <= _("Z"); t++)
  Kt.push(t);
const es = [
  _(" "),
  _("\f"),
  _(`
`),
  _("\r"),
  _("	"),
  _("\v"),
  _("	"),
  _(" "),
  _(" "),
  _(" "),
  _(" "),
  _(" "),
  _(" "),
  _(" "),
  _(" "),
  _(" "),
  _(" "),
  _(" "),
  _(" "),
  _(" "),
  _("\u2028"),
  _("\u2029"),
  _(" "),
  _(" "),
  _("　"),
  _("\uFEFF")
], Bh = /[0-9a-fA-F]/, Lt = /[0-9]/, Hh = /[1-9]/;
class Kh {
  constructor() {
    this.idx = 0, this.input = "", this.groupIdx = 0;
  }
  saveState() {
    return {
      idx: this.idx,
      input: this.input,
      groupIdx: this.groupIdx
    };
  }
  restoreState(e) {
    this.idx = e.idx, this.input = e.input, this.groupIdx = e.groupIdx;
  }
  pattern(e) {
    this.idx = 0, this.input = e, this.groupIdx = 0, this.consumeChar("/");
    const n = this.disjunction();
    this.consumeChar("/");
    const r = {
      type: "Flags",
      loc: { begin: this.idx, end: e.length },
      global: !1,
      ignoreCase: !1,
      multiLine: !1,
      unicode: !1,
      sticky: !1
    };
    for (; this.isRegExpFlag(); )
      switch (this.popChar()) {
        case "g":
          it(r, "global");
          break;
        case "i":
          it(r, "ignoreCase");
          break;
        case "m":
          it(r, "multiLine");
          break;
        case "u":
          it(r, "unicode");
          break;
        case "y":
          it(r, "sticky");
          break;
      }
    if (this.idx !== this.input.length)
      throw Error("Redundant input: " + this.input.substring(this.idx));
    return {
      type: "Pattern",
      flags: r,
      value: n,
      loc: this.loc(0)
    };
  }
  disjunction() {
    const e = [], n = this.idx;
    for (e.push(this.alternative()); this.peekChar() === "|"; )
      this.consumeChar("|"), e.push(this.alternative());
    return { type: "Disjunction", value: e, loc: this.loc(n) };
  }
  alternative() {
    const e = [], n = this.idx;
    for (; this.isTerm(); )
      e.push(this.term());
    return { type: "Alternative", value: e, loc: this.loc(n) };
  }
  term() {
    return this.isAssertion() ? this.assertion() : this.atom();
  }
  assertion() {
    const e = this.idx;
    switch (this.popChar()) {
      case "^":
        return {
          type: "StartAnchor",
          loc: this.loc(e)
        };
      case "$":
        return { type: "EndAnchor", loc: this.loc(e) };
      // '\b' or '\B'
      case "\\":
        switch (this.popChar()) {
          case "b":
            return {
              type: "WordBoundary",
              loc: this.loc(e)
            };
          case "B":
            return {
              type: "NonWordBoundary",
              loc: this.loc(e)
            };
        }
        throw Error("Invalid Assertion Escape");
      // '(?=' or '(?!'
      case "(":
        this.consumeChar("?");
        let n;
        switch (this.popChar()) {
          case "=":
            n = "Lookahead";
            break;
          case "!":
            n = "NegativeLookahead";
            break;
        }
        ze(n);
        const r = this.disjunction();
        return this.consumeChar(")"), {
          type: n,
          value: r,
          loc: this.loc(e)
        };
    }
    return Gh();
  }
  quantifier(e = !1) {
    let n;
    const r = this.idx;
    switch (this.popChar()) {
      case "*":
        n = {
          atLeast: 0,
          atMost: 1 / 0
        };
        break;
      case "+":
        n = {
          atLeast: 1,
          atMost: 1 / 0
        };
        break;
      case "?":
        n = {
          atLeast: 0,
          atMost: 1
        };
        break;
      case "{":
        const s = this.integerIncludingZero();
        switch (this.popChar()) {
          case "}":
            n = {
              atLeast: s,
              atMost: s
            };
            break;
          case ",":
            let i;
            this.isDigit() ? (i = this.integerIncludingZero(), n = {
              atLeast: s,
              atMost: i
            }) : n = {
              atLeast: s,
              atMost: 1 / 0
            }, this.consumeChar("}");
            break;
        }
        if (e === !0 && n === void 0)
          return;
        ze(n);
        break;
    }
    if (!(e === !0 && n === void 0) && ze(n))
      return this.peekChar(0) === "?" ? (this.consumeChar("?"), n.greedy = !1) : n.greedy = !0, n.type = "Quantifier", n.loc = this.loc(r), n;
  }
  atom() {
    let e;
    const n = this.idx;
    switch (this.peekChar()) {
      case ".":
        e = this.dotAll();
        break;
      case "\\":
        e = this.atomEscape();
        break;
      case "[":
        e = this.characterClass();
        break;
      case "(":
        e = this.group();
        break;
    }
    if (e === void 0 && this.isPatternCharacter() && (e = this.patternCharacter()), ze(e))
      return e.loc = this.loc(n), this.isQuantifier() && (e.quantifier = this.quantifier()), e;
  }
  dotAll() {
    return this.consumeChar("."), {
      type: "Set",
      complement: !0,
      value: [_(`
`), _("\r"), _("\u2028"), _("\u2029")]
    };
  }
  atomEscape() {
    switch (this.consumeChar("\\"), this.peekChar()) {
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        return this.decimalEscapeAtom();
      case "d":
      case "D":
      case "s":
      case "S":
      case "w":
      case "W":
        return this.characterClassEscape();
      case "f":
      case "n":
      case "r":
      case "t":
      case "v":
        return this.controlEscapeAtom();
      case "c":
        return this.controlLetterEscapeAtom();
      case "0":
        return this.nulCharacterAtom();
      case "x":
        return this.hexEscapeSequenceAtom();
      case "u":
        return this.regExpUnicodeEscapeSequenceAtom();
      default:
        return this.identityEscapeAtom();
    }
  }
  decimalEscapeAtom() {
    return { type: "GroupBackReference", value: this.positiveInteger() };
  }
  characterClassEscape() {
    let e, n = !1;
    switch (this.popChar()) {
      case "d":
        e = Ht;
        break;
      case "D":
        e = Ht, n = !0;
        break;
      case "s":
        e = es;
        break;
      case "S":
        e = es, n = !0;
        break;
      case "w":
        e = Kt;
        break;
      case "W":
        e = Kt, n = !0;
        break;
    }
    if (ze(e))
      return { type: "Set", value: e, complement: n };
  }
  controlEscapeAtom() {
    let e;
    switch (this.popChar()) {
      case "f":
        e = _("\f");
        break;
      case "n":
        e = _(`
`);
        break;
      case "r":
        e = _("\r");
        break;
      case "t":
        e = _("	");
        break;
      case "v":
        e = _("\v");
        break;
    }
    if (ze(e))
      return { type: "Character", value: e };
  }
  controlLetterEscapeAtom() {
    this.consumeChar("c");
    const e = this.popChar();
    if (/[a-zA-Z]/.test(e) === !1)
      throw Error("Invalid ");
    return { type: "Character", value: e.toUpperCase().charCodeAt(0) - 64 };
  }
  nulCharacterAtom() {
    return this.consumeChar("0"), { type: "Character", value: _("\0") };
  }
  hexEscapeSequenceAtom() {
    return this.consumeChar("x"), this.parseHexDigits(2);
  }
  regExpUnicodeEscapeSequenceAtom() {
    return this.consumeChar("u"), this.parseHexDigits(4);
  }
  identityEscapeAtom() {
    const e = this.popChar();
    return { type: "Character", value: _(e) };
  }
  classPatternCharacterAtom() {
    switch (this.peekChar()) {
      // istanbul ignore next
      case `
`:
      // istanbul ignore next
      case "\r":
      // istanbul ignore next
      case "\u2028":
      // istanbul ignore next
      case "\u2029":
      // istanbul ignore next
      case "\\":
      // istanbul ignore next
      case "]":
        throw Error("TBD");
      default:
        const e = this.popChar();
        return { type: "Character", value: _(e) };
    }
  }
  characterClass() {
    const e = [];
    let n = !1;
    for (this.consumeChar("["), this.peekChar(0) === "^" && (this.consumeChar("^"), n = !0); this.isClassAtom(); ) {
      const r = this.classAtom();
      if (r.type, Jr(r) && this.isRangeDash()) {
        this.consumeChar("-");
        const s = this.classAtom();
        if (s.type, Jr(s)) {
          if (s.value < r.value)
            throw Error("Range out of order in character class");
          e.push({ from: r.value, to: s.value });
        } else
          An(r.value, e), e.push(_("-")), An(s.value, e);
      } else
        An(r.value, e);
    }
    return this.consumeChar("]"), { type: "Set", complement: n, value: e };
  }
  classAtom() {
    switch (this.peekChar()) {
      // istanbul ignore next
      case "]":
      // istanbul ignore next
      case `
`:
      // istanbul ignore next
      case "\r":
      // istanbul ignore next
      case "\u2028":
      // istanbul ignore next
      case "\u2029":
        throw Error("TBD");
      case "\\":
        return this.classEscape();
      default:
        return this.classPatternCharacterAtom();
    }
  }
  classEscape() {
    switch (this.consumeChar("\\"), this.peekChar()) {
      // Matches a backspace.
      // (Not to be confused with \b word boundary outside characterClass)
      case "b":
        return this.consumeChar("b"), { type: "Character", value: _("\b") };
      case "d":
      case "D":
      case "s":
      case "S":
      case "w":
      case "W":
        return this.characterClassEscape();
      case "f":
      case "n":
      case "r":
      case "t":
      case "v":
        return this.controlEscapeAtom();
      case "c":
        return this.controlLetterEscapeAtom();
      case "0":
        return this.nulCharacterAtom();
      case "x":
        return this.hexEscapeSequenceAtom();
      case "u":
        return this.regExpUnicodeEscapeSequenceAtom();
      default:
        return this.identityEscapeAtom();
    }
  }
  group() {
    let e = !0;
    switch (this.consumeChar("("), this.peekChar(0)) {
      case "?":
        this.consumeChar("?"), this.consumeChar(":"), e = !1;
        break;
      default:
        this.groupIdx++;
        break;
    }
    const n = this.disjunction();
    this.consumeChar(")");
    const r = {
      type: "Group",
      capturing: e,
      value: n
    };
    return e && (r.idx = this.groupIdx), r;
  }
  positiveInteger() {
    let e = this.popChar();
    if (Hh.test(e) === !1)
      throw Error("Expecting a positive integer");
    for (; Lt.test(this.peekChar(0)); )
      e += this.popChar();
    return parseInt(e, 10);
  }
  integerIncludingZero() {
    let e = this.popChar();
    if (Lt.test(e) === !1)
      throw Error("Expecting an integer");
    for (; Lt.test(this.peekChar(0)); )
      e += this.popChar();
    return parseInt(e, 10);
  }
  patternCharacter() {
    const e = this.popChar();
    switch (e) {
      // istanbul ignore next
      case `
`:
      // istanbul ignore next
      case "\r":
      // istanbul ignore next
      case "\u2028":
      // istanbul ignore next
      case "\u2029":
      // istanbul ignore next
      case "^":
      // istanbul ignore next
      case "$":
      // istanbul ignore next
      case "\\":
      // istanbul ignore next
      case ".":
      // istanbul ignore next
      case "*":
      // istanbul ignore next
      case "+":
      // istanbul ignore next
      case "?":
      // istanbul ignore next
      case "(":
      // istanbul ignore next
      case ")":
      // istanbul ignore next
      case "[":
      // istanbul ignore next
      case "|":
        throw Error("TBD");
      default:
        return { type: "Character", value: _(e) };
    }
  }
  isRegExpFlag() {
    switch (this.peekChar(0)) {
      case "g":
      case "i":
      case "m":
      case "u":
      case "y":
        return !0;
      default:
        return !1;
    }
  }
  isRangeDash() {
    return this.peekChar() === "-" && this.isClassAtom(1);
  }
  isDigit() {
    return Lt.test(this.peekChar(0));
  }
  isClassAtom(e = 0) {
    switch (this.peekChar(e)) {
      case "]":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        return !1;
      default:
        return !0;
    }
  }
  isTerm() {
    return this.isAtom() || this.isAssertion();
  }
  isAtom() {
    if (this.isPatternCharacter())
      return !0;
    switch (this.peekChar(0)) {
      case ".":
      case "\\":
      // atomEscape
      case "[":
      // characterClass
      // TODO: isAtom must be called before isAssertion - disambiguate
      case "(":
        return !0;
      default:
        return !1;
    }
  }
  isAssertion() {
    switch (this.peekChar(0)) {
      case "^":
      case "$":
        return !0;
      // '\b' or '\B'
      case "\\":
        switch (this.peekChar(1)) {
          case "b":
          case "B":
            return !0;
          default:
            return !1;
        }
      // '(?=' or '(?!'
      case "(":
        return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
      default:
        return !1;
    }
  }
  isQuantifier() {
    const e = this.saveState();
    try {
      return this.quantifier(!0) !== void 0;
    } catch {
      return !1;
    } finally {
      this.restoreState(e);
    }
  }
  isPatternCharacter() {
    switch (this.peekChar()) {
      case "^":
      case "$":
      case "\\":
      case ".":
      case "*":
      case "+":
      case "?":
      case "(":
      case ")":
      case "[":
      case "|":
      case "/":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        return !1;
      default:
        return !0;
    }
  }
  parseHexDigits(e) {
    let n = "";
    for (let s = 0; s < e; s++) {
      const i = this.popChar();
      if (Bh.test(i) === !1)
        throw Error("Expecting a HexDecimal digits");
      n += i;
    }
    return { type: "Character", value: parseInt(n, 16) };
  }
  peekChar(e = 0) {
    return this.input[this.idx + e];
  }
  popChar() {
    const e = this.peekChar(0);
    return this.consumeChar(void 0), e;
  }
  consumeChar(e) {
    if (e !== void 0 && this.input[this.idx] !== e)
      throw Error("Expected: '" + e + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx);
    if (this.idx >= this.input.length)
      throw Error("Unexpected end of input");
    this.idx++;
  }
  loc(e) {
    return { begin: e, end: this.idx };
  }
}
class or {
  visitChildren(e) {
    for (const n in e) {
      const r = e[n];
      e.hasOwnProperty(n) && (r.type !== void 0 ? this.visit(r) : Array.isArray(r) && r.forEach((s) => {
        this.visit(s);
      }, this));
    }
  }
  visit(e) {
    switch (e.type) {
      case "Pattern":
        this.visitPattern(e);
        break;
      case "Flags":
        this.visitFlags(e);
        break;
      case "Disjunction":
        this.visitDisjunction(e);
        break;
      case "Alternative":
        this.visitAlternative(e);
        break;
      case "StartAnchor":
        this.visitStartAnchor(e);
        break;
      case "EndAnchor":
        this.visitEndAnchor(e);
        break;
      case "WordBoundary":
        this.visitWordBoundary(e);
        break;
      case "NonWordBoundary":
        this.visitNonWordBoundary(e);
        break;
      case "Lookahead":
        this.visitLookahead(e);
        break;
      case "NegativeLookahead":
        this.visitNegativeLookahead(e);
        break;
      case "Character":
        this.visitCharacter(e);
        break;
      case "Set":
        this.visitSet(e);
        break;
      case "Group":
        this.visitGroup(e);
        break;
      case "GroupBackReference":
        this.visitGroupBackReference(e);
        break;
      case "Quantifier":
        this.visitQuantifier(e);
        break;
    }
    this.visitChildren(e);
  }
  visitPattern(e) {
  }
  visitFlags(e) {
  }
  visitDisjunction(e) {
  }
  visitAlternative(e) {
  }
  // Assertion
  visitStartAnchor(e) {
  }
  visitEndAnchor(e) {
  }
  visitWordBoundary(e) {
  }
  visitNonWordBoundary(e) {
  }
  visitLookahead(e) {
  }
  visitNegativeLookahead(e) {
  }
  // atoms
  visitCharacter(e) {
  }
  visitSet(e) {
  }
  visitGroup(e) {
  }
  visitGroupBackReference(e) {
  }
  visitQuantifier(e) {
  }
}
let bt = {};
const Wh = new Kh();
function ln(t) {
  const e = t.toString();
  if (bt.hasOwnProperty(e))
    return bt[e];
  {
    const n = Wh.pattern(e);
    return bt[e] = n, n;
  }
}
function jh() {
  bt = {};
}
const ni = "Complement Sets are not supported for first char optimization", Wt = `Unable to use "first char" lexer optimizations:
`;
function zh(t, e = !1) {
  try {
    const n = ln(t);
    return vn(n.value, {}, n.flags.ignoreCase);
  } catch (n) {
    if (n.message === ni)
      e && Qs(`${Wt}	Unable to optimize: < ${t.toString()} >
	Complement Sets cannot be automatically optimized.
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);
    else {
      let r = "";
      e && (r = `
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.`), yn(`${Wt}
	Failed parsing: < ${t.toString()} >
	Using the @chevrotain/regexp-to-ast library
	Please open an issue at: https://github.com/chevrotain/chevrotain/issues` + r);
    }
  }
  return [];
}
function vn(t, e, n) {
  switch (t.type) {
    case "Disjunction":
      for (let s = 0; s < t.value.length; s++)
        vn(t.value[s], e, n);
      break;
    case "Alternative":
      const r = t.value;
      for (let s = 0; s < r.length; s++) {
        const i = r[s];
        switch (i.type) {
          case "EndAnchor":
          // A group back reference cannot affect potential starting char.
          // because if a back reference is the first production than automatically
          // the group being referenced has had to come BEFORE so its codes have already been added
          case "GroupBackReference":
          // assertions do not affect potential starting codes
          case "Lookahead":
          case "NegativeLookahead":
          case "StartAnchor":
          case "WordBoundary":
          case "NonWordBoundary":
            continue;
        }
        const a = i;
        switch (a.type) {
          case "Character":
            yt(a.value, e, n);
            break;
          case "Set":
            if (a.complement === !0)
              throw Error(ni);
            S(a.value, (c) => {
              if (typeof c == "number")
                yt(c, e, n);
              else {
                const u = c;
                if (n === !0)
                  for (let l = u.from; l <= u.to; l++)
                    yt(l, e, n);
                else {
                  for (let l = u.from; l <= u.to && l < ct; l++)
                    yt(l, e, n);
                  if (u.to >= ct) {
                    const l = u.from >= ct ? u.from : ct, h = u.to, f = xe(l), p = xe(h);
                    for (let T = f; T <= p; T++)
                      e[T] = T;
                  }
                }
              }
            });
            break;
          case "Group":
            vn(a.value, e, n);
            break;
          /* istanbul ignore next */
          default:
            throw Error("Non Exhaustive Match");
        }
        const o = a.quantifier !== void 0 && a.quantifier.atLeast === 0;
        if (
          // A group may be optional due to empty contents /(?:)/
          // or if everything inside it is optional /((a)?)/
          a.type === "Group" && Pn(a) === !1 || // If this term is not a group it may only be optional if it has an optional quantifier
          a.type !== "Group" && o === !1
        )
          break;
      }
      break;
    /* istanbul ignore next */
    default:
      throw Error("non exhaustive match!");
  }
  return w(e);
}
function yt(t, e, n) {
  const r = xe(t);
  e[r] = r, n === !0 && Vh(t, e);
}
function Vh(t, e) {
  const n = String.fromCharCode(t), r = n.toUpperCase();
  if (r !== n) {
    const s = xe(r.charCodeAt(0));
    e[s] = s;
  } else {
    const s = n.toLowerCase();
    if (s !== n) {
      const i = xe(s.charCodeAt(0));
      e[i] = i;
    }
  }
}
function ts(t, e) {
  return Ze(t.value, (n) => {
    if (typeof n == "number")
      return H(e, n);
    {
      const r = n;
      return Ze(e, (s) => r.from <= s && s <= r.to) !== void 0;
    }
  });
}
function Pn(t) {
  const e = t.quantifier;
  return e && e.atLeast === 0 ? !0 : t.value ? N(t.value) ? ae(t.value, Pn) : Pn(t.value) : !1;
}
class Yh extends or {
  constructor(e) {
    super(), this.targetCharCodes = e, this.found = !1;
  }
  visitChildren(e) {
    if (this.found !== !0) {
      switch (e.type) {
        case "Lookahead":
          this.visitLookahead(e);
          return;
        case "NegativeLookahead":
          this.visitNegativeLookahead(e);
          return;
      }
      super.visitChildren(e);
    }
  }
  visitCharacter(e) {
    H(this.targetCharCodes, e.value) && (this.found = !0);
  }
  visitSet(e) {
    e.complement ? ts(e, this.targetCharCodes) === void 0 && (this.found = !0) : ts(e, this.targetCharCodes) !== void 0 && (this.found = !0);
  }
}
function cr(t, e) {
  if (e instanceof RegExp) {
    const n = ln(e), r = new Yh(t);
    return r.visit(n), r.found;
  } else
    return Ze(e, (n) => H(t, n.charCodeAt(0))) !== void 0;
}
const Ge = "PATTERN", ot = "defaultMode", vt = "modes";
let ri = typeof new RegExp("(?:)").sticky == "boolean";
function Xh(t, e) {
  e = ir(e, {
    useSticky: ri,
    debug: !1,
    safeMode: !1,
    positionTracking: "full",
    lineTerminatorCharacters: ["\r", `
`],
    tracer: (E, d) => d()
  });
  const n = e.tracer;
  n("initCharCodeToOptimizedIndexMap", () => {
    Af();
  });
  let r;
  n("Reject Lexer.NA", () => {
    r = cn(t, (E) => E[Ge] === G.NA);
  });
  let s = !1, i;
  n("Transform Patterns", () => {
    s = !1, i = A(r, (E) => {
      const d = E[Ge];
      if (Se(d)) {
        const m = d.source;
        return m.length === 1 && // only these regExp meta characters which can appear in a length one regExp
        m !== "^" && m !== "$" && m !== "." && !d.ignoreCase ? m : m.length === 2 && m[0] === "\\" && // not a meta character
        !H([
          "d",
          "D",
          "s",
          "S",
          "t",
          "r",
          "n",
          "t",
          "0",
          "c",
          "b",
          "B",
          "f",
          "v",
          "w",
          "W"
        ], m[1]) ? m[1] : e.useSticky ? rs(d) : ns(d);
      } else {
        if (Ne(d))
          return s = !0, { exec: d };
        if (typeof d == "object")
          return s = !0, d;
        if (typeof d == "string") {
          if (d.length === 1)
            return d;
          {
            const m = d.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&"), L = new RegExp(m);
            return e.useSticky ? rs(L) : ns(L);
          }
        } else
          throw Error("non exhaustive match");
      }
    });
  });
  let a, o, c, u, l;
  n("misc mapping", () => {
    a = A(r, (E) => E.tokenTypeIdx), o = A(r, (E) => {
      const d = E.GROUP;
      if (d !== G.SKIPPED) {
        if (W(d))
          return d;
        if (_e(d))
          return !1;
        throw Error("non exhaustive match");
      }
    }), c = A(r, (E) => {
      const d = E.LONGER_ALT;
      if (d)
        return N(d) ? A(d, (L) => qr(r, L)) : [qr(r, d)];
    }), u = A(r, (E) => E.PUSH_MODE), l = A(r, (E) => R(E, "POP_MODE"));
  });
  let h;
  n("Line Terminator Handling", () => {
    const E = ai(e.lineTerminatorCharacters);
    h = A(r, (d) => !1), e.positionTracking !== "onlyOffset" && (h = A(r, (d) => R(d, "LINE_BREAKS") ? !!d.LINE_BREAKS : ii(d, E) === !1 && cr(E, d.PATTERN)));
  });
  let f, p, T, I;
  n("Misc Mapping #2", () => {
    f = A(r, si), p = A(i, gf), T = Y(r, (E, d) => {
      const m = d.GROUP;
      return W(m) && m !== G.SKIPPED && (E[m] = []), E;
    }, {}), I = A(i, (E, d) => ({
      pattern: i[d],
      longerAlt: c[d],
      canLineTerminator: h[d],
      isCustom: f[d],
      short: p[d],
      group: o[d],
      push: u[d],
      pop: l[d],
      tokenTypeIdx: a[d],
      tokenType: r[d]
    }));
  });
  let O = !0, g = [];
  return e.safeMode || n("First Char Optimization", () => {
    g = Y(r, (E, d, m) => {
      if (typeof d.PATTERN == "string") {
        const L = d.PATTERN.charCodeAt(0), re = xe(L);
        Rn(E, re, I[m]);
      } else if (N(d.START_CHARS_HINT)) {
        let L;
        S(d.START_CHARS_HINT, (re) => {
          const ye = typeof re == "string" ? re.charCodeAt(0) : re, Ue = xe(ye);
          L !== Ue && (L = Ue, Rn(E, Ue, I[m]));
        });
      } else if (Se(d.PATTERN))
        if (d.PATTERN.unicode)
          O = !1, e.ensureOptimizations && yn(`${Wt}	Unable to analyze < ${d.PATTERN.toString()} > pattern.
	The regexp unicode flag is not currently supported by the regexp-to-ast library.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);
        else {
          const L = zh(d.PATTERN, e.ensureOptimizations);
          v(L) && (O = !1), S(L, (re) => {
            Rn(E, re, I[m]);
          });
        }
      else
        e.ensureOptimizations && yn(`${Wt}	TokenType: <${d.name}> is using a custom token pattern without providing <start_chars_hint> parameter.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`), O = !1;
      return E;
    }, []);
  }), {
    emptyGroups: T,
    patternIdxToConfig: I,
    charCodeToPatternIdxToConfig: g,
    hasCustom: s,
    canBeOptimized: O
  };
}
function qh(t, e) {
  let n = [];
  const r = Qh(t);
  n = n.concat(r.errors);
  const s = Jh(r.valid), i = s.valid;
  return n = n.concat(s.errors), n = n.concat(Zh(i)), n = n.concat(cf(i)), n = n.concat(uf(i, e)), n = n.concat(lf(i)), n;
}
function Zh(t) {
  let e = [];
  const n = ne(t, (r) => Se(r[Ge]));
  return e = e.concat(tf(n)), e = e.concat(sf(n)), e = e.concat(af(n)), e = e.concat(of(n)), e = e.concat(nf(n)), e;
}
function Qh(t) {
  const e = ne(t, (s) => !R(s, Ge)), n = A(e, (s) => ({
    message: "Token Type: ->" + s.name + "<- missing static 'PATTERN' property",
    type: x.MISSING_PATTERN,
    tokenTypes: [s]
  })), r = on(t, e);
  return { errors: n, valid: r };
}
function Jh(t) {
  const e = ne(t, (s) => {
    const i = s[Ge];
    return !Se(i) && !Ne(i) && !R(i, "exec") && !W(i);
  }), n = A(e, (s) => ({
    message: "Token Type: ->" + s.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
    type: x.INVALID_PATTERN,
    tokenTypes: [s]
  })), r = on(t, e);
  return { errors: n, valid: r };
}
const ef = /[^\\][$]/;
function tf(t) {
  class e extends or {
    constructor() {
      super(...arguments), this.found = !1;
    }
    visitEndAnchor(i) {
      this.found = !0;
    }
  }
  const n = ne(t, (s) => {
    const i = s.PATTERN;
    try {
      const a = ln(i), o = new e();
      return o.visit(a), o.found;
    } catch {
      return ef.test(i.source);
    }
  });
  return A(n, (s) => ({
    message: `Unexpected RegExp Anchor Error:
	Token Type: ->` + s.name + `<- static 'PATTERN' cannot contain end of input anchor '$'
	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
    type: x.EOI_ANCHOR_FOUND,
    tokenTypes: [s]
  }));
}
function nf(t) {
  const e = ne(t, (r) => r.PATTERN.test(""));
  return A(e, (r) => ({
    message: "Token Type: ->" + r.name + "<- static 'PATTERN' must not match an empty string",
    type: x.EMPTY_MATCH_PATTERN,
    tokenTypes: [r]
  }));
}
const rf = /[^\\[][\^]|^\^/;
function sf(t) {
  class e extends or {
    constructor() {
      super(...arguments), this.found = !1;
    }
    visitStartAnchor(i) {
      this.found = !0;
    }
  }
  const n = ne(t, (s) => {
    const i = s.PATTERN;
    try {
      const a = ln(i), o = new e();
      return o.visit(a), o.found;
    } catch {
      return rf.test(i.source);
    }
  });
  return A(n, (s) => ({
    message: `Unexpected RegExp Anchor Error:
	Token Type: ->` + s.name + `<- static 'PATTERN' cannot contain start of input anchor '^'
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
    type: x.SOI_ANCHOR_FOUND,
    tokenTypes: [s]
  }));
}
function af(t) {
  const e = ne(t, (r) => {
    const s = r[Ge];
    return s instanceof RegExp && (s.multiline || s.global);
  });
  return A(e, (r) => ({
    message: "Token Type: ->" + r.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
    type: x.UNSUPPORTED_FLAGS_FOUND,
    tokenTypes: [r]
  }));
}
function of(t) {
  const e = [];
  let n = A(t, (i) => Y(t, (a, o) => (i.PATTERN.source === o.PATTERN.source && !H(e, o) && o.PATTERN !== G.NA && (e.push(o), a.push(o)), a), []));
  n = At(n);
  const r = ne(n, (i) => i.length > 1);
  return A(r, (i) => {
    const a = A(i, (c) => c.name);
    return {
      message: `The same RegExp pattern ->${ce(i).PATTERN}<-has been used in all of the following Token Types: ${a.join(", ")} <-`,
      type: x.DUPLICATE_PATTERNS_FOUND,
      tokenTypes: i
    };
  });
}
function cf(t) {
  const e = ne(t, (r) => {
    if (!R(r, "GROUP"))
      return !1;
    const s = r.GROUP;
    return s !== G.SKIPPED && s !== G.NA && !W(s);
  });
  return A(e, (r) => ({
    message: "Token Type: ->" + r.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
    type: x.INVALID_GROUP_TYPE_FOUND,
    tokenTypes: [r]
  }));
}
function uf(t, e) {
  const n = ne(t, (s) => s.PUSH_MODE !== void 0 && !H(e, s.PUSH_MODE));
  return A(n, (s) => ({
    message: `Token Type: ->${s.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${s.PUSH_MODE}<-which does not exist`,
    type: x.PUSH_MODE_DOES_NOT_EXIST,
    tokenTypes: [s]
  }));
}
function lf(t) {
  const e = [], n = Y(t, (r, s, i) => {
    const a = s.PATTERN;
    return a === G.NA || (W(a) ? r.push({ str: a, idx: i, tokenType: s }) : Se(a) && ff(a) && r.push({ str: a.source, idx: i, tokenType: s })), r;
  }, []);
  return S(t, (r, s) => {
    S(n, ({ str: i, idx: a, tokenType: o }) => {
      if (s < a && hf(i, r.PATTERN)) {
        const c = `Token: ->${o.name}<- can never be matched.
Because it appears AFTER the Token Type ->${r.name}<-in the lexer's definition.
See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;
        e.push({
          message: c,
          type: x.UNREACHABLE_PATTERN,
          tokenTypes: [r, o]
        });
      }
    });
  }), e;
}
function hf(t, e) {
  if (Se(e)) {
    const n = e.exec(t);
    return n !== null && n.index === 0;
  } else {
    if (Ne(e))
      return e(t, 0, [], {});
    if (R(e, "exec"))
      return e.exec(t, 0, [], {});
    if (typeof e == "string")
      return e === t;
    throw Error("non exhaustive match");
  }
}
function ff(t) {
  return Ze([
    ".",
    "\\",
    "[",
    "]",
    "|",
    "^",
    "$",
    "(",
    ")",
    "?",
    "*",
    "+",
    "{"
  ], (n) => t.source.indexOf(n) !== -1) === void 0;
}
function ns(t) {
  const e = t.ignoreCase ? "i" : "";
  return new RegExp(`^(?:${t.source})`, e);
}
function rs(t) {
  const e = t.ignoreCase ? "iy" : "y";
  return new RegExp(`${t.source}`, e);
}
function df(t, e, n) {
  const r = [];
  return R(t, ot) || r.push({
    message: "A MultiMode Lexer cannot be initialized without a <" + ot + `> property in its definition
`,
    type: x.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
  }), R(t, vt) || r.push({
    message: "A MultiMode Lexer cannot be initialized without a <" + vt + `> property in its definition
`,
    type: x.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
  }), R(t, vt) && R(t, ot) && !R(t.modes, t.defaultMode) && r.push({
    message: `A MultiMode Lexer cannot be initialized with a ${ot}: <${t.defaultMode}>which does not exist
`,
    type: x.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
  }), R(t, vt) && S(t.modes, (s, i) => {
    S(s, (a, o) => {
      if (_e(a))
        r.push({
          message: `A Lexer cannot be initialized using an undefined Token Type. Mode:<${i}> at index: <${o}>
`,
          type: x.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
        });
      else if (R(a, "LONGER_ALT")) {
        const c = N(a.LONGER_ALT) ? a.LONGER_ALT : [a.LONGER_ALT];
        S(c, (u) => {
          !_e(u) && !H(s, u) && r.push({
            message: `A MultiMode Lexer cannot be initialized with a longer_alt <${u.name}> on token <${a.name}> outside of mode <${i}>
`,
            type: x.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE
          });
        });
      }
    });
  }), r;
}
function pf(t, e, n) {
  const r = [];
  let s = !1;
  const i = At(ie(w(t.modes))), a = cn(i, (c) => c[Ge] === G.NA), o = ai(n);
  return e && S(a, (c) => {
    const u = ii(c, o);
    if (u !== !1) {
      const h = {
        message: mf(c, u),
        type: u.issue,
        tokenType: c
      };
      r.push(h);
    } else
      R(c, "LINE_BREAKS") ? c.LINE_BREAKS === !0 && (s = !0) : cr(o, c.PATTERN) && (s = !0);
  }), e && !s && r.push({
    message: `Warning: No LINE_BREAKS Found.
	This Lexer has been defined to track line and column information,
	But none of the Token Types can be identified as matching a line terminator.
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS 
	for details.`,
    type: x.NO_LINE_BREAKS_FLAGS
  }), r;
}
function Ef(t) {
  const e = {}, n = te(t);
  return S(n, (r) => {
    const s = t[r];
    if (N(s))
      e[r] = [];
    else
      throw Error("non exhaustive match");
  }), e;
}
function si(t) {
  const e = t.PATTERN;
  if (Se(e))
    return !1;
  if (Ne(e))
    return !0;
  if (R(e, "exec"))
    return !0;
  if (W(e))
    return !1;
  throw Error("non exhaustive match");
}
function gf(t) {
  return W(t) && t.length === 1 ? t.charCodeAt(0) : !1;
}
const Tf = {
  // implements /\n|\r\n?/g.test
  test: function(t) {
    const e = t.length;
    for (let n = this.lastIndex; n < e; n++) {
      const r = t.charCodeAt(n);
      if (r === 10)
        return this.lastIndex = n + 1, !0;
      if (r === 13)
        return t.charCodeAt(n + 1) === 10 ? this.lastIndex = n + 2 : this.lastIndex = n + 1, !0;
    }
    return !1;
  },
  lastIndex: 0
};
function ii(t, e) {
  if (R(t, "LINE_BREAKS"))
    return !1;
  if (Se(t.PATTERN)) {
    try {
      cr(e, t.PATTERN);
    } catch (n) {
      return {
        issue: x.IDENTIFY_TERMINATOR,
        errMsg: n.message
      };
    }
    return !1;
  } else {
    if (W(t.PATTERN))
      return !1;
    if (si(t))
      return { issue: x.CUSTOM_LINE_BREAK };
    throw Error("non exhaustive match");
  }
}
function mf(t, e) {
  if (e.issue === x.IDENTIFY_TERMINATOR)
    return `Warning: unable to identify line terminator usage in pattern.
	The problem is in the <${t.name}> Token Type
	 Root cause: ${e.errMsg}.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`;
  if (e.issue === x.CUSTOM_LINE_BREAK)
    return `Warning: A Custom Token Pattern should specify the <line_breaks> option.
	The problem is in the <${t.name}> Token Type
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`;
  throw Error("non exhaustive match");
}
function ai(t) {
  return A(t, (n) => W(n) ? n.charCodeAt(0) : n);
}
function Rn(t, e, n) {
  t[e] === void 0 ? t[e] = [n] : t[e].push(n);
}
const ct = 256;
let wt = [];
function xe(t) {
  return t < ct ? t : wt[t];
}
function Af() {
  if (v(wt)) {
    wt = new Array(65536);
    for (let t = 0; t < 65536; t++)
      wt[t] = t > 255 ? 255 + ~~(t / 255) : t;
  }
}
function It(t, e) {
  const n = t.tokenTypeIdx;
  return n === e.tokenTypeIdx ? !0 : e.isParent === !0 && e.categoryMatchesMap[n] === !0;
}
function jt(t, e) {
  return t.tokenTypeIdx === e.tokenTypeIdx;
}
let ss = 1;
const oi = {};
function St(t) {
  const e = Rf(t);
  If(e), _f(e), Sf(e), S(e, (n) => {
    n.isParent = n.categoryMatches.length > 0;
  });
}
function Rf(t) {
  let e = D(t), n = t, r = !0;
  for (; r; ) {
    n = At(ie(A(n, (i) => i.CATEGORIES)));
    const s = on(n, e);
    e = e.concat(s), v(s) ? r = !1 : n = s;
  }
  return e;
}
function If(t) {
  S(t, (e) => {
    ui(e) || (oi[ss] = e, e.tokenTypeIdx = ss++), is(e) && !N(e.CATEGORIES) && (e.CATEGORIES = [e.CATEGORIES]), is(e) || (e.CATEGORIES = []), Of(e) || (e.categoryMatches = []), Nf(e) || (e.categoryMatchesMap = {});
  });
}
function Sf(t) {
  S(t, (e) => {
    e.categoryMatches = [], S(e.categoryMatchesMap, (n, r) => {
      e.categoryMatches.push(oi[r].tokenTypeIdx);
    });
  });
}
function _f(t) {
  S(t, (e) => {
    ci([], e);
  });
}
function ci(t, e) {
  S(t, (n) => {
    e.categoryMatchesMap[n.tokenTypeIdx] = !0;
  }), S(e.CATEGORIES, (n) => {
    const r = t.concat(e);
    H(r, n) || ci(r, n);
  });
}
function ui(t) {
  return R(t, "tokenTypeIdx");
}
function is(t) {
  return R(t, "CATEGORIES");
}
function Of(t) {
  return R(t, "categoryMatches");
}
function Nf(t) {
  return R(t, "categoryMatchesMap");
}
function Cf(t) {
  return R(t, "tokenTypeIdx");
}
const Lf = {
  buildUnableToPopLexerModeMessage(t) {
    return `Unable to pop Lexer Mode after encountering Token ->${t.image}<- The Mode Stack is empty`;
  },
  buildUnexpectedCharactersMessage(t, e, n, r, s) {
    return `unexpected character: ->${t.charAt(e)}<- at offset: ${e}, skipped ${n} characters.`;
  }
};
var x;
(function(t) {
  t[t.MISSING_PATTERN = 0] = "MISSING_PATTERN", t[t.INVALID_PATTERN = 1] = "INVALID_PATTERN", t[t.EOI_ANCHOR_FOUND = 2] = "EOI_ANCHOR_FOUND", t[t.UNSUPPORTED_FLAGS_FOUND = 3] = "UNSUPPORTED_FLAGS_FOUND", t[t.DUPLICATE_PATTERNS_FOUND = 4] = "DUPLICATE_PATTERNS_FOUND", t[t.INVALID_GROUP_TYPE_FOUND = 5] = "INVALID_GROUP_TYPE_FOUND", t[t.PUSH_MODE_DOES_NOT_EXIST = 6] = "PUSH_MODE_DOES_NOT_EXIST", t[t.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE", t[t.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY", t[t.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST", t[t.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED", t[t.SOI_ANCHOR_FOUND = 11] = "SOI_ANCHOR_FOUND", t[t.EMPTY_MATCH_PATTERN = 12] = "EMPTY_MATCH_PATTERN", t[t.NO_LINE_BREAKS_FLAGS = 13] = "NO_LINE_BREAKS_FLAGS", t[t.UNREACHABLE_PATTERN = 14] = "UNREACHABLE_PATTERN", t[t.IDENTIFY_TERMINATOR = 15] = "IDENTIFY_TERMINATOR", t[t.CUSTOM_LINE_BREAK = 16] = "CUSTOM_LINE_BREAK", t[t.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";
})(x || (x = {}));
const ut = {
  deferDefinitionErrorsHandling: !1,
  positionTracking: "full",
  lineTerminatorsPattern: /\n|\r\n?/g,
  lineTerminatorCharacters: [`
`, "\r"],
  ensureOptimizations: !1,
  safeMode: !1,
  errorMessageProvider: Lf,
  traceInitPerf: !1,
  skipValidations: !1,
  recoveryEnabled: !0
};
Object.freeze(ut);
class G {
  constructor(e, n = ut) {
    if (this.lexerDefinition = e, this.lexerDefinitionErrors = [], this.lexerDefinitionWarning = [], this.patternIdxToConfig = {}, this.charCodeToPatternIdxToConfig = {}, this.modes = [], this.emptyGroups = {}, this.trackStartLines = !0, this.trackEndLines = !0, this.hasCustom = !1, this.canModeBeOptimized = {}, this.TRACE_INIT = (s, i) => {
      if (this.traceInitPerf === !0) {
        this.traceInitIndent++;
        const a = new Array(this.traceInitIndent + 1).join("	");
        this.traceInitIndent < this.traceInitMaxIdent && console.log(`${a}--> <${s}>`);
        const { time: o, value: c } = Js(i), u = o > 10 ? console.warn : console.log;
        return this.traceInitIndent < this.traceInitMaxIdent && u(`${a}<-- <${s}> time: ${o}ms`), this.traceInitIndent--, c;
      } else
        return i();
    }, typeof n == "boolean")
      throw Error(`The second argument to the Lexer constructor is now an ILexerConfig Object.
a boolean 2nd argument is no longer supported`);
    this.config = V({}, ut, n);
    const r = this.config.traceInitPerf;
    r === !0 ? (this.traceInitMaxIdent = 1 / 0, this.traceInitPerf = !0) : typeof r == "number" && (this.traceInitMaxIdent = r, this.traceInitPerf = !0), this.traceInitIndent = -1, this.TRACE_INIT("Lexer Constructor", () => {
      let s, i = !0;
      this.TRACE_INIT("Lexer Config handling", () => {
        if (this.config.lineTerminatorsPattern === ut.lineTerminatorsPattern)
          this.config.lineTerminatorsPattern = Tf;
        else if (this.config.lineTerminatorCharacters === ut.lineTerminatorCharacters)
          throw Error(`Error: Missing <lineTerminatorCharacters> property on the Lexer config.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS`);
        if (n.safeMode && n.ensureOptimizations)
          throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
        this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking), this.trackEndLines = /full/i.test(this.config.positionTracking), N(e) ? s = {
          modes: { defaultMode: D(e) },
          defaultMode: ot
        } : (i = !1, s = D(e));
      }), this.config.skipValidations === !1 && (this.TRACE_INIT("performRuntimeChecks", () => {
        this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(df(s, this.trackStartLines, this.config.lineTerminatorCharacters));
      }), this.TRACE_INIT("performWarningRuntimeChecks", () => {
        this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(pf(s, this.trackStartLines, this.config.lineTerminatorCharacters));
      })), s.modes = s.modes ? s.modes : {}, S(s.modes, (o, c) => {
        s.modes[c] = cn(o, (u) => _e(u));
      });
      const a = te(s.modes);
      if (S(s.modes, (o, c) => {
        this.TRACE_INIT(`Mode: <${c}> processing`, () => {
          if (this.modes.push(c), this.config.skipValidations === !1 && this.TRACE_INIT("validatePatterns", () => {
            this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(qh(o, a));
          }), v(this.lexerDefinitionErrors)) {
            St(o);
            let u;
            this.TRACE_INIT("analyzeTokenTypes", () => {
              u = Xh(o, {
                lineTerminatorCharacters: this.config.lineTerminatorCharacters,
                positionTracking: n.positionTracking,
                ensureOptimizations: n.ensureOptimizations,
                safeMode: n.safeMode,
                tracer: this.TRACE_INIT
              });
            }), this.patternIdxToConfig[c] = u.patternIdxToConfig, this.charCodeToPatternIdxToConfig[c] = u.charCodeToPatternIdxToConfig, this.emptyGroups = V({}, this.emptyGroups, u.emptyGroups), this.hasCustom = u.hasCustom || this.hasCustom, this.canModeBeOptimized[c] = u.canBeOptimized;
          }
        });
      }), this.defaultMode = s.defaultMode, !v(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling) {
        const c = A(this.lexerDefinitionErrors, (u) => u.message).join(`-----------------------
`);
        throw new Error(`Errors detected in definition of Lexer:
` + c);
      }
      S(this.lexerDefinitionWarning, (o) => {
        Qs(o.message);
      }), this.TRACE_INIT("Choosing sub-methods implementations", () => {
        if (ri ? (this.chopInput = Ye, this.match = this.matchWithTest) : (this.updateLastIndex = b, this.match = this.matchWithExec), i && (this.handleModes = b), this.trackStartLines === !1 && (this.computeNewColumn = Ye), this.trackEndLines === !1 && (this.updateTokenEndLineColumnLocation = b), /full/i.test(this.config.positionTracking))
          this.createTokenInstance = this.createFullToken;
        else if (/onlyStart/i.test(this.config.positionTracking))
          this.createTokenInstance = this.createStartOnlyToken;
        else if (/onlyOffset/i.test(this.config.positionTracking))
          this.createTokenInstance = this.createOffsetOnlyToken;
        else
          throw Error(`Invalid <positionTracking> config option: "${this.config.positionTracking}"`);
        this.hasCustom ? (this.addToken = this.addTokenUsingPush, this.handlePayload = this.handlePayloadWithCustom) : (this.addToken = this.addTokenUsingMemberAccess, this.handlePayload = this.handlePayloadNoCustom);
      }), this.TRACE_INIT("Failed Optimization Warnings", () => {
        const o = Y(this.canModeBeOptimized, (c, u, l) => (u === !1 && c.push(l), c), []);
        if (n.ensureOptimizations && !v(o))
          throw Error(`Lexer Modes: < ${o.join(", ")} > cannot be optimized.
	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.
	 Or inspect the console log for details on how to resolve these issues.`);
      }), this.TRACE_INIT("clearRegExpParserCache", () => {
        jh();
      }), this.TRACE_INIT("toFastProperties", () => {
        ei(this);
      });
    });
  }
  tokenize(e, n = this.defaultMode) {
    if (!v(this.lexerDefinitionErrors)) {
      const s = A(this.lexerDefinitionErrors, (i) => i.message).join(`-----------------------
`);
      throw new Error(`Unable to Tokenize because Errors detected in definition of Lexer:
` + s);
    }
    return this.tokenizeInternal(e, n);
  }
  // There is quite a bit of duplication between this and "tokenizeInternalLazy"
  // This is intentional due to performance considerations.
  // this method also used quite a bit of `!` none null assertions because it is too optimized
  // for `tsc` to always understand it is "safe"
  tokenizeInternal(e, n) {
    let r, s, i, a, o, c, u, l, h, f, p, T, I, O, g;
    const E = e, d = E.length;
    let m = 0, L = 0;
    const re = this.hasCustom ? 0 : Math.floor(e.length / 10), ye = new Array(re), Ue = [];
    let et = this.trackStartLines ? 1 : void 0, ve = this.trackStartLines ? 1 : void 0;
    const tt = Ef(this.emptyGroups), qi = this.trackStartLines, pn = this.config.lineTerminatorsPattern;
    let Ot = 0, Pe = [], nt = [];
    const Nt = [], dr = [];
    Object.freeze(dr);
    let rt;
    function pr() {
      return Pe;
    }
    function Er($) {
      const q = xe($), je = nt[q];
      return je === void 0 ? dr : je;
    }
    const Zi = ($) => {
      if (Nt.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
      // So no error should occur.
      $.tokenType.PUSH_MODE === void 0) {
        const q = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage($);
        Ue.push({
          offset: $.startOffset,
          line: $.startLine,
          column: $.startColumn,
          length: $.image.length,
          message: q
        });
      } else {
        Nt.pop();
        const q = qe(Nt);
        Pe = this.patternIdxToConfig[q], nt = this.charCodeToPatternIdxToConfig[q], Ot = Pe.length;
        const je = this.canModeBeOptimized[q] && this.config.safeMode === !1;
        nt && je ? rt = Er : rt = pr;
      }
    };
    function gr($) {
      Nt.push($), nt = this.charCodeToPatternIdxToConfig[$], Pe = this.patternIdxToConfig[$], Ot = Pe.length, Ot = Pe.length;
      const q = this.canModeBeOptimized[$] && this.config.safeMode === !1;
      nt && q ? rt = Er : rt = pr;
    }
    gr.call(this, n);
    let se;
    const Tr = this.config.recoveryEnabled;
    for (; m < d; ) {
      c = null;
      const $ = E.charCodeAt(m), q = rt($), je = q.length;
      for (r = 0; r < je; r++) {
        se = q[r];
        const z = se.pattern;
        u = null;
        const Re = se.short;
        if (Re !== !1 ? $ === Re && (c = z) : se.isCustom === !0 ? (g = z.exec(E, m, ye, tt), g !== null ? (c = g[0], g.payload !== void 0 && (u = g.payload)) : c = null) : (this.updateLastIndex(z, m), c = this.match(z, e, m)), c !== null) {
          if (o = se.longerAlt, o !== void 0) {
            const Me = o.length;
            for (i = 0; i < Me; i++) {
              const Ie = Pe[o[i]], Fe = Ie.pattern;
              if (l = null, Ie.isCustom === !0 ? (g = Fe.exec(E, m, ye, tt), g !== null ? (a = g[0], g.payload !== void 0 && (l = g.payload)) : a = null) : (this.updateLastIndex(Fe, m), a = this.match(Fe, e, m)), a && a.length > c.length) {
                c = a, u = l, se = Ie;
                break;
              }
            }
          }
          break;
        }
      }
      if (c !== null) {
        if (h = c.length, f = se.group, f !== void 0 && (p = se.tokenTypeIdx, T = this.createTokenInstance(c, m, p, se.tokenType, et, ve, h), this.handlePayload(T, u), f === !1 ? L = this.addToken(ye, L, T) : tt[f].push(T)), e = this.chopInput(e, h), m = m + h, ve = this.computeNewColumn(ve, h), qi === !0 && se.canLineTerminator === !0) {
          let z = 0, Re, Me;
          pn.lastIndex = 0;
          do
            Re = pn.test(c), Re === !0 && (Me = pn.lastIndex - 1, z++);
          while (Re === !0);
          z !== 0 && (et = et + z, ve = h - Me, this.updateTokenEndLineColumnLocation(T, f, Me, z, et, ve, h));
        }
        this.handleModes(se, Zi, gr, T);
      } else {
        const z = m, Re = et, Me = ve;
        let Ie = Tr === !1;
        for (; Ie === !1 && m < d; )
          for (e = this.chopInput(e, 1), m++, s = 0; s < Ot; s++) {
            const Fe = Pe[s], En = Fe.pattern, mr = Fe.short;
            if (mr !== !1 ? E.charCodeAt(m) === mr && (Ie = !0) : Fe.isCustom === !0 ? Ie = En.exec(E, m, ye, tt) !== null : (this.updateLastIndex(En, m), Ie = En.exec(e) !== null), Ie === !0)
              break;
          }
        if (I = m - z, ve = this.computeNewColumn(ve, I), O = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(E, z, I, Re, Me), Ue.push({
          offset: z,
          line: Re,
          column: Me,
          length: I,
          message: O
        }), Tr === !1)
          break;
      }
    }
    return this.hasCustom || (ye.length = L), {
      tokens: ye,
      groups: tt,
      errors: Ue
    };
  }
  handleModes(e, n, r, s) {
    if (e.pop === !0) {
      const i = e.push;
      n(s), i !== void 0 && r.call(this, i);
    } else e.push !== void 0 && r.call(this, e.push);
  }
  chopInput(e, n) {
    return e.substring(n);
  }
  updateLastIndex(e, n) {
    e.lastIndex = n;
  }
  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler
  updateTokenEndLineColumnLocation(e, n, r, s, i, a, o) {
    let c, u;
    n !== void 0 && (c = r === o - 1, u = c ? -1 : 0, s === 1 && c === !0 || (e.endLine = i + u, e.endColumn = a - 1 + -u));
  }
  computeNewColumn(e, n) {
    return e + n;
  }
  createOffsetOnlyToken(e, n, r, s) {
    return {
      image: e,
      startOffset: n,
      tokenTypeIdx: r,
      tokenType: s
    };
  }
  createStartOnlyToken(e, n, r, s, i, a) {
    return {
      image: e,
      startOffset: n,
      startLine: i,
      startColumn: a,
      tokenTypeIdx: r,
      tokenType: s
    };
  }
  createFullToken(e, n, r, s, i, a, o) {
    return {
      image: e,
      startOffset: n,
      endOffset: n + o - 1,
      startLine: i,
      endLine: i,
      startColumn: a,
      endColumn: a + o - 1,
      tokenTypeIdx: r,
      tokenType: s
    };
  }
  addTokenUsingPush(e, n, r) {
    return e.push(r), n;
  }
  addTokenUsingMemberAccess(e, n, r) {
    return e[n] = r, n++, n;
  }
  handlePayloadNoCustom(e, n) {
  }
  handlePayloadWithCustom(e, n) {
    n !== null && (e.payload = n);
  }
  matchWithTest(e, n, r) {
    return e.test(n) === !0 ? n.substring(r, e.lastIndex) : null;
  }
  matchWithExec(e, n) {
    const r = e.exec(n);
    return r !== null ? r[0] : null;
  }
}
G.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
G.NA = /NOT_APPLICABLE/;
function ht(t) {
  return li(t) ? t.LABEL : t.name;
}
function li(t) {
  return W(t.LABEL) && t.LABEL !== "";
}
const yf = "parent", as = "categories", os = "label", cs = "group", us = "push_mode", ls = "pop_mode", hs = "longer_alt", fs = "line_breaks", ds = "start_chars_hint";
function C(t) {
  return vf(t);
}
function vf(t) {
  const e = t.pattern, n = {};
  if (n.name = t.name, _e(e) || (n.PATTERN = e), R(t, yf))
    throw `The parent property is no longer supported.
See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.`;
  return R(t, as) && (n.CATEGORIES = t[as]), St([n]), R(t, os) && (n.LABEL = t[os]), R(t, cs) && (n.GROUP = t[cs]), R(t, ls) && (n.POP_MODE = t[ls]), R(t, us) && (n.PUSH_MODE = t[us]), R(t, hs) && (n.LONGER_ALT = t[hs]), R(t, fs) && (n.LINE_BREAKS = t[fs]), R(t, ds) && (n.START_CHARS_HINT = t[ds]), n;
}
const Be = C({ name: "EOF", pattern: G.NA });
St([Be]);
function ur(t, e, n, r, s, i, a, o) {
  return {
    image: e,
    startOffset: n,
    endOffset: r,
    startLine: s,
    endLine: i,
    startColumn: a,
    endColumn: o,
    tokenTypeIdx: t.tokenTypeIdx,
    tokenType: t
  };
}
function Pf(t, e) {
  return It(t, e);
}
const hi = {
  buildMismatchTokenMessage({ expected: t, actual: e, previous: n, ruleName: r }) {
    return `Expecting ${li(t) ? `--> ${ht(t)} <--` : `token of type --> ${t.name} <--`} but found --> '${e.image}' <--`;
  },
  buildNotAllInputParsedMessage({ firstRedundant: t, ruleName: e }) {
    return "Redundant input, expecting EOF but found: " + t.image;
  },
  buildNoViableAltMessage({ expectedPathsPerAlt: t, actual: e, previous: n, customUserDescription: r, ruleName: s }) {
    const i = "Expecting: ", o = `
but found: '` + ce(e).image + "'";
    if (r)
      return i + r + o;
    {
      const c = Y(t, (f, p) => f.concat(p), []), u = A(c, (f) => `[${A(f, (p) => ht(p)).join(", ")}]`), h = `one of these possible Token sequences:
${A(u, (f, p) => `  ${p + 1}. ${f}`).join(`
`)}`;
      return i + h + o;
    }
  },
  buildEarlyExitMessage({ expectedIterationPaths: t, actual: e, customUserDescription: n, ruleName: r }) {
    const s = "Expecting: ", a = `
but found: '` + ce(e).image + "'";
    if (n)
      return s + n + a;
    {
      const c = `expecting at least one iteration which starts with one of these possible Token sequences::
  <${A(t, (u) => `[${A(u, (l) => ht(l)).join(",")}]`).join(" ,")}>`;
      return s + c + a;
    }
  }
};
Object.freeze(hi);
const Mf = {
  buildRuleNotFoundError(t, e) {
    return "Invalid grammar, reference to a rule which is not defined: ->" + e.nonTerminalName + `<-
inside top level rule: ->` + t.name + "<-";
  }
}, De = {
  buildDuplicateFoundError(t, e) {
    function n(l) {
      return l instanceof M ? l.terminalType.name : l instanceof X ? l.nonTerminalName : "";
    }
    const r = t.name, s = ce(e), i = s.idx, a = fe(s), o = n(s), c = i > 0;
    let u = `->${a}${c ? i : ""}<- ${o ? `with argument: ->${o}<-` : ""}
                  appears more than once (${e.length} times) in the top level rule: ->${r}<-.                  
                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES 
                  `;
    return u = u.replace(/[ \t]+/g, " "), u = u.replace(/\s\s+/g, `
`), u;
  },
  buildNamespaceConflictError(t) {
    return `Namespace conflict found in grammar.
The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${t.name}>.
To resolve this make sure each Terminal and Non-Terminal names are unique
This is easy to accomplish by using the convention that Terminal names start with an uppercase letter
and Non-Terminal names start with a lower case letter.`;
  },
  buildAlternationPrefixAmbiguityError(t) {
    const e = A(t.prefixPath, (s) => ht(s)).join(", "), n = t.alternation.idx === 0 ? "" : t.alternation.idx;
    return `Ambiguous alternatives: <${t.ambiguityIndices.join(" ,")}> due to common lookahead prefix
in <OR${n}> inside <${t.topLevelRule.name}> Rule,
<${e}> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX
For Further details.`;
  },
  buildAlternationAmbiguityError(t) {
    const e = A(t.prefixPath, (s) => ht(s)).join(", "), n = t.alternation.idx === 0 ? "" : t.alternation.idx;
    let r = `Ambiguous Alternatives Detected: <${t.ambiguityIndices.join(" ,")}> in <OR${n}> inside <${t.topLevelRule.name}> Rule,
<${e}> may appears as a prefix path in all these alternatives.
`;
    return r = r + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`, r;
  },
  buildEmptyRepetitionError(t) {
    let e = fe(t.repetition);
    return t.repetition.idx !== 0 && (e += t.repetition.idx), `The repetition <${e}> within Rule <${t.topLevelRule.name}> can never consume any tokens.
This could lead to an infinite loop.`;
  },
  // TODO: remove - `errors_public` from nyc.config.js exclude
  //       once this method is fully removed from this file
  buildTokenNameError(t) {
    return "deprecated";
  },
  buildEmptyAlternationError(t) {
    return `Ambiguous empty alternative: <${t.emptyChoiceIdx + 1}> in <OR${t.alternation.idx}> inside <${t.topLevelRule.name}> Rule.
Only the last alternative may be an empty alternative.`;
  },
  buildTooManyAlternativesError(t) {
    return `An Alternation cannot have more than 256 alternatives:
<OR${t.alternation.idx}> inside <${t.topLevelRule.name}> Rule.
 has ${t.alternation.definition.length + 1} alternatives.`;
  },
  buildLeftRecursionError(t) {
    const e = t.topLevelRule.name, n = A(t.leftRecursionPath, (i) => i.name), r = `${e} --> ${n.concat([e]).join(" --> ")}`;
    return `Left Recursion found in grammar.
rule: <${e}> can be invoked from itself (directly or indirectly)
without consuming any Tokens. The grammar path that causes this is: 
 ${r}
 To fix this refactor your grammar to remove the left recursion.
see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;
  },
  // TODO: remove - `errors_public` from nyc.config.js exclude
  //       once this method is fully removed from this file
  buildInvalidRuleNameError(t) {
    return "deprecated";
  },
  buildDuplicateRuleNameError(t) {
    let e;
    return t.topLevelRule instanceof Qe ? e = t.topLevelRule.name : e = t.topLevelRule, `Duplicate definition, rule: ->${e}<- is already defined in the grammar: ->${t.grammarName}<-`;
  }
};
function kf(t, e) {
  const n = new xf(t, e);
  return n.resolveRefs(), n.errors;
}
class xf extends Je {
  constructor(e, n) {
    super(), this.nameToTopRule = e, this.errMsgProvider = n, this.errors = [];
  }
  resolveRefs() {
    S(w(this.nameToTopRule), (e) => {
      this.currTopLevel = e, e.accept(this);
    });
  }
  visitNonTerminal(e) {
    const n = this.nameToTopRule[e.nonTerminalName];
    if (n)
      e.referencedRule = n;
    else {
      const r = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, e);
      this.errors.push({
        message: r,
        type: B.UNRESOLVED_SUBRULE_REF,
        ruleName: this.currTopLevel.name,
        unresolvedRefName: e.nonTerminalName
      });
    }
  }
}
class bf extends un {
  constructor(e, n) {
    super(), this.topProd = e, this.path = n, this.possibleTokTypes = [], this.nextProductionName = "", this.nextProductionOccurrence = 0, this.found = !1, this.isAtEndOfPath = !1;
  }
  startWalking() {
    if (this.found = !1, this.path.ruleStack[0] !== this.topProd.name)
      throw Error("The path does not start with the walker's top Rule!");
    return this.ruleStack = D(this.path.ruleStack).reverse(), this.occurrenceStack = D(this.path.occurrenceStack).reverse(), this.ruleStack.pop(), this.occurrenceStack.pop(), this.updateExpectedNext(), this.walk(this.topProd), this.possibleTokTypes;
  }
  walk(e, n = []) {
    this.found || super.walk(e, n);
  }
  walkProdRef(e, n, r) {
    if (e.referencedRule.name === this.nextProductionName && e.idx === this.nextProductionOccurrence) {
      const s = n.concat(r);
      this.updateExpectedNext(), this.walk(e.referencedRule, s);
    }
  }
  updateExpectedNext() {
    v(this.ruleStack) ? (this.nextProductionName = "", this.nextProductionOccurrence = 0, this.isAtEndOfPath = !0) : (this.nextProductionName = this.ruleStack.pop(), this.nextProductionOccurrence = this.occurrenceStack.pop());
  }
}
class wf extends bf {
  constructor(e, n) {
    super(e, n), this.path = n, this.nextTerminalName = "", this.nextTerminalOccurrence = 0, this.nextTerminalName = this.path.lastTok.name, this.nextTerminalOccurrence = this.path.lastTokOccurrence;
  }
  walkTerminal(e, n, r) {
    if (this.isAtEndOfPath && e.terminalType.name === this.nextTerminalName && e.idx === this.nextTerminalOccurrence && !this.found) {
      const s = n.concat(r), i = new j({ definition: s });
      this.possibleTokTypes = Rt(i), this.found = !0;
    }
  }
}
class hn extends un {
  constructor(e, n) {
    super(), this.topRule = e, this.occurrence = n, this.result = {
      token: void 0,
      occurrence: void 0,
      isEndOfRule: void 0
    };
  }
  startWalking() {
    return this.walk(this.topRule), this.result;
  }
}
class Uf extends hn {
  walkMany(e, n, r) {
    if (e.idx === this.occurrence) {
      const s = ce(n.concat(r));
      this.result.isEndOfRule = s === void 0, s instanceof M && (this.result.token = s.terminalType, this.result.occurrence = s.idx);
    } else
      super.walkMany(e, n, r);
  }
}
class ps extends hn {
  walkManySep(e, n, r) {
    if (e.idx === this.occurrence) {
      const s = ce(n.concat(r));
      this.result.isEndOfRule = s === void 0, s instanceof M && (this.result.token = s.terminalType, this.result.occurrence = s.idx);
    } else
      super.walkManySep(e, n, r);
  }
}
class Ff extends hn {
  walkAtLeastOne(e, n, r) {
    if (e.idx === this.occurrence) {
      const s = ce(n.concat(r));
      this.result.isEndOfRule = s === void 0, s instanceof M && (this.result.token = s.terminalType, this.result.occurrence = s.idx);
    } else
      super.walkAtLeastOne(e, n, r);
  }
}
class Es extends hn {
  walkAtLeastOneSep(e, n, r) {
    if (e.idx === this.occurrence) {
      const s = ce(n.concat(r));
      this.result.isEndOfRule = s === void 0, s instanceof M && (this.result.token = s.terminalType, this.result.occurrence = s.idx);
    } else
      super.walkAtLeastOneSep(e, n, r);
  }
}
function Mn(t, e, n = []) {
  n = D(n);
  let r = [], s = 0;
  function i(o) {
    return o.concat(F(t, s + 1));
  }
  function a(o) {
    const c = Mn(i(o), e, n);
    return r.concat(c);
  }
  for (; n.length < e && s < t.length; ) {
    const o = t[s];
    if (o instanceof j)
      return a(o.definition);
    if (o instanceof X)
      return a(o.definition);
    if (o instanceof K)
      r = a(o.definition);
    else if (o instanceof me) {
      const c = o.definition.concat([
        new U({
          definition: o.definition
        })
      ]);
      return a(c);
    } else if (o instanceof Ae) {
      const c = [
        new j({ definition: o.definition }),
        new U({
          definition: [new M({ terminalType: o.separator })].concat(o.definition)
        })
      ];
      return a(c);
    } else if (o instanceof le) {
      const c = o.definition.concat([
        new U({
          definition: [new M({ terminalType: o.separator })].concat(o.definition)
        })
      ]);
      r = a(c);
    } else if (o instanceof U) {
      const c = o.definition.concat([
        new U({
          definition: o.definition
        })
      ]);
      r = a(c);
    } else {
      if (o instanceof he)
        return S(o.definition, (c) => {
          v(c.definition) === !1 && (r = a(c.definition));
        }), r;
      if (o instanceof M)
        n.push(o.terminalType);
      else
        throw Error("non exhaustive match");
    }
    s++;
  }
  return r.push({
    partialPath: n,
    suffixDef: F(t, s)
  }), r;
}
function fi(t, e, n, r) {
  const s = "EXIT_NONE_TERMINAL", i = [s], a = "EXIT_ALTERNATIVE";
  let o = !1;
  const c = e.length, u = c - r - 1, l = [], h = [];
  for (h.push({
    idx: -1,
    def: t,
    ruleStack: [],
    occurrenceStack: []
  }); !v(h); ) {
    const f = h.pop();
    if (f === a) {
      o && qe(h).idx <= u && h.pop();
      continue;
    }
    const p = f.def, T = f.idx, I = f.ruleStack, O = f.occurrenceStack;
    if (v(p))
      continue;
    const g = p[0];
    if (g === s) {
      const E = {
        idx: T,
        def: F(p),
        ruleStack: Et(I),
        occurrenceStack: Et(O)
      };
      h.push(E);
    } else if (g instanceof M)
      if (T < c - 1) {
        const E = T + 1, d = e[E];
        if (n(d, g.terminalType)) {
          const m = {
            idx: E,
            def: F(p),
            ruleStack: I,
            occurrenceStack: O
          };
          h.push(m);
        }
      } else if (T === c - 1)
        l.push({
          nextTokenType: g.terminalType,
          nextTokenOccurrence: g.idx,
          ruleStack: I,
          occurrenceStack: O
        }), o = !0;
      else
        throw Error("non exhaustive match");
    else if (g instanceof X) {
      const E = D(I);
      E.push(g.nonTerminalName);
      const d = D(O);
      d.push(g.idx);
      const m = {
        idx: T,
        def: g.definition.concat(i, F(p)),
        ruleStack: E,
        occurrenceStack: d
      };
      h.push(m);
    } else if (g instanceof K) {
      const E = {
        idx: T,
        def: F(p),
        ruleStack: I,
        occurrenceStack: O
      };
      h.push(E), h.push(a);
      const d = {
        idx: T,
        def: g.definition.concat(F(p)),
        ruleStack: I,
        occurrenceStack: O
      };
      h.push(d);
    } else if (g instanceof me) {
      const E = new U({
        definition: g.definition,
        idx: g.idx
      }), d = g.definition.concat([E], F(p)), m = {
        idx: T,
        def: d,
        ruleStack: I,
        occurrenceStack: O
      };
      h.push(m);
    } else if (g instanceof Ae) {
      const E = new M({
        terminalType: g.separator
      }), d = new U({
        definition: [E].concat(g.definition),
        idx: g.idx
      }), m = g.definition.concat([d], F(p)), L = {
        idx: T,
        def: m,
        ruleStack: I,
        occurrenceStack: O
      };
      h.push(L);
    } else if (g instanceof le) {
      const E = {
        idx: T,
        def: F(p),
        ruleStack: I,
        occurrenceStack: O
      };
      h.push(E), h.push(a);
      const d = new M({
        terminalType: g.separator
      }), m = new U({
        definition: [d].concat(g.definition),
        idx: g.idx
      }), L = g.definition.concat([m], F(p)), re = {
        idx: T,
        def: L,
        ruleStack: I,
        occurrenceStack: O
      };
      h.push(re);
    } else if (g instanceof U) {
      const E = {
        idx: T,
        def: F(p),
        ruleStack: I,
        occurrenceStack: O
      };
      h.push(E), h.push(a);
      const d = new U({
        definition: g.definition,
        idx: g.idx
      }), m = g.definition.concat([d], F(p)), L = {
        idx: T,
        def: m,
        ruleStack: I,
        occurrenceStack: O
      };
      h.push(L);
    } else if (g instanceof he)
      for (let E = g.definition.length - 1; E >= 0; E--) {
        const d = g.definition[E], m = {
          idx: T,
          def: d.definition.concat(F(p)),
          ruleStack: I,
          occurrenceStack: O
        };
        h.push(m), h.push(a);
      }
    else if (g instanceof j)
      h.push({
        idx: T,
        def: g.definition.concat(F(p)),
        ruleStack: I,
        occurrenceStack: O
      });
    else if (g instanceof Qe)
      h.push(Df(g, T, I, O));
    else
      throw Error("non exhaustive match");
  }
  return l;
}
function Df(t, e, n, r) {
  const s = D(n);
  s.push(t.name);
  const i = D(r);
  return i.push(1), {
    idx: e,
    def: t.definition,
    ruleStack: s,
    occurrenceStack: i
  };
}
var k;
(function(t) {
  t[t.OPTION = 0] = "OPTION", t[t.REPETITION = 1] = "REPETITION", t[t.REPETITION_MANDATORY = 2] = "REPETITION_MANDATORY", t[t.REPETITION_MANDATORY_WITH_SEPARATOR = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR", t[t.REPETITION_WITH_SEPARATOR = 4] = "REPETITION_WITH_SEPARATOR", t[t.ALTERNATION = 5] = "ALTERNATION";
})(k || (k = {}));
function di(t) {
  if (t instanceof K || t === "Option")
    return k.OPTION;
  if (t instanceof U || t === "Repetition")
    return k.REPETITION;
  if (t instanceof me || t === "RepetitionMandatory")
    return k.REPETITION_MANDATORY;
  if (t instanceof Ae || t === "RepetitionMandatoryWithSeparator")
    return k.REPETITION_MANDATORY_WITH_SEPARATOR;
  if (t instanceof le || t === "RepetitionWithSeparator")
    return k.REPETITION_WITH_SEPARATOR;
  if (t instanceof he || t === "Alternation")
    return k.ALTERNATION;
  throw Error("non exhaustive match");
}
function $f(t, e, n, r, s, i) {
  const a = lr(t, e, n), o = gi(a) ? jt : It;
  return i(a, r, o, s);
}
function Gf(t, e, n, r, s, i) {
  const a = hr(t, e, s, n), o = gi(a) ? jt : It;
  return i(a[0], o, r);
}
function Bf(t, e, n, r) {
  const s = t.length, i = ae(t, (a) => ae(a, (o) => o.length === 1));
  if (e)
    return function(a) {
      const o = A(a, (c) => c.GATE);
      for (let c = 0; c < s; c++) {
        const u = t[c], l = u.length, h = o[c];
        if (!(h !== void 0 && h.call(this) === !1))
          e: for (let f = 0; f < l; f++) {
            const p = u[f], T = p.length;
            for (let I = 0; I < T; I++) {
              const O = this.LA(I + 1);
              if (n(O, p[I]) === !1)
                continue e;
            }
            return c;
          }
      }
    };
  if (i && !r) {
    const a = A(t, (c) => ie(c)), o = Y(a, (c, u, l) => (S(u, (h) => {
      R(c, h.tokenTypeIdx) || (c[h.tokenTypeIdx] = l), S(h.categoryMatches, (f) => {
        R(c, f) || (c[f] = l);
      });
    }), c), {});
    return function() {
      const c = this.LA(1);
      return o[c.tokenTypeIdx];
    };
  } else
    return function() {
      for (let a = 0; a < s; a++) {
        const o = t[a], c = o.length;
        e: for (let u = 0; u < c; u++) {
          const l = o[u], h = l.length;
          for (let f = 0; f < h; f++) {
            const p = this.LA(f + 1);
            if (n(p, l[f]) === !1)
              continue e;
          }
          return a;
        }
      }
    };
}
function Hf(t, e, n) {
  const r = ae(t, (i) => i.length === 1), s = t.length;
  if (r && !n) {
    const i = ie(t);
    if (i.length === 1 && v(i[0].categoryMatches)) {
      const o = i[0].tokenTypeIdx;
      return function() {
        return this.LA(1).tokenTypeIdx === o;
      };
    } else {
      const a = Y(i, (o, c, u) => (o[c.tokenTypeIdx] = !0, S(c.categoryMatches, (l) => {
        o[l] = !0;
      }), o), []);
      return function() {
        const o = this.LA(1);
        return a[o.tokenTypeIdx] === !0;
      };
    }
  } else
    return function() {
      e: for (let i = 0; i < s; i++) {
        const a = t[i], o = a.length;
        for (let c = 0; c < o; c++) {
          const u = this.LA(c + 1);
          if (e(u, a[c]) === !1)
            continue e;
        }
        return !0;
      }
      return !1;
    };
}
class Kf extends un {
  constructor(e, n, r) {
    super(), this.topProd = e, this.targetOccurrence = n, this.targetProdType = r;
  }
  startWalking() {
    return this.walk(this.topProd), this.restDef;
  }
  checkIsTarget(e, n, r, s) {
    return e.idx === this.targetOccurrence && this.targetProdType === n ? (this.restDef = r.concat(s), !0) : !1;
  }
  walkOption(e, n, r) {
    this.checkIsTarget(e, k.OPTION, n, r) || super.walkOption(e, n, r);
  }
  walkAtLeastOne(e, n, r) {
    this.checkIsTarget(e, k.REPETITION_MANDATORY, n, r) || super.walkOption(e, n, r);
  }
  walkAtLeastOneSep(e, n, r) {
    this.checkIsTarget(e, k.REPETITION_MANDATORY_WITH_SEPARATOR, n, r) || super.walkOption(e, n, r);
  }
  walkMany(e, n, r) {
    this.checkIsTarget(e, k.REPETITION, n, r) || super.walkOption(e, n, r);
  }
  walkManySep(e, n, r) {
    this.checkIsTarget(e, k.REPETITION_WITH_SEPARATOR, n, r) || super.walkOption(e, n, r);
  }
}
class pi extends Je {
  constructor(e, n, r) {
    super(), this.targetOccurrence = e, this.targetProdType = n, this.targetRef = r, this.result = [];
  }
  checkIsTarget(e, n) {
    e.idx === this.targetOccurrence && this.targetProdType === n && (this.targetRef === void 0 || e === this.targetRef) && (this.result = e.definition);
  }
  visitOption(e) {
    this.checkIsTarget(e, k.OPTION);
  }
  visitRepetition(e) {
    this.checkIsTarget(e, k.REPETITION);
  }
  visitRepetitionMandatory(e) {
    this.checkIsTarget(e, k.REPETITION_MANDATORY);
  }
  visitRepetitionMandatoryWithSeparator(e) {
    this.checkIsTarget(e, k.REPETITION_MANDATORY_WITH_SEPARATOR);
  }
  visitRepetitionWithSeparator(e) {
    this.checkIsTarget(e, k.REPETITION_WITH_SEPARATOR);
  }
  visitAlternation(e) {
    this.checkIsTarget(e, k.ALTERNATION);
  }
}
function gs(t) {
  const e = new Array(t);
  for (let n = 0; n < t; n++)
    e[n] = [];
  return e;
}
function In(t) {
  let e = [""];
  for (let n = 0; n < t.length; n++) {
    const r = t[n], s = [];
    for (let i = 0; i < e.length; i++) {
      const a = e[i];
      s.push(a + "_" + r.tokenTypeIdx);
      for (let o = 0; o < r.categoryMatches.length; o++) {
        const c = "_" + r.categoryMatches[o];
        s.push(a + c);
      }
    }
    e = s;
  }
  return e;
}
function Wf(t, e, n) {
  for (let r = 0; r < t.length; r++) {
    if (r === n)
      continue;
    const s = t[r];
    for (let i = 0; i < e.length; i++) {
      const a = e[i];
      if (s[a] === !0)
        return !1;
    }
  }
  return !0;
}
function Ei(t, e) {
  const n = A(t, (a) => Mn([a], 1)), r = gs(n.length), s = A(n, (a) => {
    const o = {};
    return S(a, (c) => {
      const u = In(c.partialPath);
      S(u, (l) => {
        o[l] = !0;
      });
    }), o;
  });
  let i = n;
  for (let a = 1; a <= e; a++) {
    const o = i;
    i = gs(o.length);
    for (let c = 0; c < o.length; c++) {
      const u = o[c];
      for (let l = 0; l < u.length; l++) {
        const h = u[l].partialPath, f = u[l].suffixDef, p = In(h);
        if (Wf(s, p, c) || v(f) || h.length === e) {
          const I = r[c];
          if (kn(I, h) === !1) {
            I.push(h);
            for (let O = 0; O < p.length; O++) {
              const g = p[O];
              s[c][g] = !0;
            }
          }
        } else {
          const I = Mn(f, a + 1, h);
          i[c] = i[c].concat(I), S(I, (O) => {
            const g = In(O.partialPath);
            S(g, (E) => {
              s[c][E] = !0;
            });
          });
        }
      }
    }
  }
  return r;
}
function lr(t, e, n, r) {
  const s = new pi(t, k.ALTERNATION, r);
  return e.accept(s), Ei(s.result, n);
}
function hr(t, e, n, r) {
  const s = new pi(t, n);
  e.accept(s);
  const i = s.result, o = new Kf(e, t, n).startWalking(), c = new j({ definition: i }), u = new j({ definition: o });
  return Ei([c, u], r);
}
function kn(t, e) {
  e: for (let n = 0; n < t.length; n++) {
    const r = t[n];
    if (r.length === e.length) {
      for (let s = 0; s < r.length; s++) {
        const i = e[s], a = r[s];
        if ((i === a || a.categoryMatchesMap[i.tokenTypeIdx] !== void 0) === !1)
          continue e;
      }
      return !0;
    }
  }
  return !1;
}
function jf(t, e) {
  return t.length < e.length && ae(t, (n, r) => {
    const s = e[r];
    return n === s || s.categoryMatchesMap[n.tokenTypeIdx];
  });
}
function gi(t) {
  return ae(t, (e) => ae(e, (n) => ae(n, (r) => v(r.categoryMatches))));
}
function zf(t) {
  const e = t.lookaheadStrategy.validate({
    rules: t.rules,
    tokenTypes: t.tokenTypes,
    grammarName: t.grammarName
  });
  return A(e, (n) => Object.assign({ type: B.CUSTOM_LOOKAHEAD_VALIDATION }, n));
}
function Vf(t, e, n, r) {
  const s = Q(t, (c) => Yf(c, n)), i = ad(t, e, n), a = Q(t, (c) => nd(c, n)), o = Q(t, (c) => Zf(c, t, r, n));
  return s.concat(i, a, o);
}
function Yf(t, e) {
  const n = new qf();
  t.accept(n);
  const r = n.allProductions, s = ah(r, Xf), i = ue(s, (o) => o.length > 1);
  return A(w(i), (o) => {
    const c = ce(o), u = e.buildDuplicateFoundError(t, o), l = fe(c), h = {
      message: u,
      type: B.DUPLICATE_PRODUCTIONS,
      ruleName: t.name,
      dslName: l,
      occurrence: c.idx
    }, f = Ti(c);
    return f && (h.parameter = f), h;
  });
}
function Xf(t) {
  return `${fe(t)}_#_${t.idx}_#_${Ti(t)}`;
}
function Ti(t) {
  return t instanceof M ? t.terminalType.name : t instanceof X ? t.nonTerminalName : "";
}
class qf extends Je {
  constructor() {
    super(...arguments), this.allProductions = [];
  }
  visitNonTerminal(e) {
    this.allProductions.push(e);
  }
  visitOption(e) {
    this.allProductions.push(e);
  }
  visitRepetitionWithSeparator(e) {
    this.allProductions.push(e);
  }
  visitRepetitionMandatory(e) {
    this.allProductions.push(e);
  }
  visitRepetitionMandatoryWithSeparator(e) {
    this.allProductions.push(e);
  }
  visitRepetition(e) {
    this.allProductions.push(e);
  }
  visitAlternation(e) {
    this.allProductions.push(e);
  }
  visitTerminal(e) {
    this.allProductions.push(e);
  }
}
function Zf(t, e, n, r) {
  const s = [];
  if (Y(e, (a, o) => o.name === t.name ? a + 1 : a, 0) > 1) {
    const a = r.buildDuplicateRuleNameError({
      topLevelRule: t,
      grammarName: n
    });
    s.push({
      message: a,
      type: B.DUPLICATE_RULE_NAME,
      ruleName: t.name
    });
  }
  return s;
}
function Qf(t, e, n) {
  const r = [];
  let s;
  return H(e, t) || (s = `Invalid rule override, rule: ->${t}<- cannot be overridden in the grammar: ->${n}<-as it is not defined in any of the super grammars `, r.push({
    message: s,
    type: B.INVALID_RULE_OVERRIDE,
    ruleName: t
  })), r;
}
function mi(t, e, n, r = []) {
  const s = [], i = Ut(e.definition);
  if (v(i))
    return [];
  {
    const a = t.name;
    H(i, t) && s.push({
      message: n.buildLeftRecursionError({
        topLevelRule: t,
        leftRecursionPath: r
      }),
      type: B.LEFT_RECURSION,
      ruleName: a
    });
    const c = on(i, r.concat([t])), u = Q(c, (l) => {
      const h = D(r);
      return h.push(l), mi(t, l, n, h);
    });
    return s.concat(u);
  }
}
function Ut(t) {
  let e = [];
  if (v(t))
    return e;
  const n = ce(t);
  if (n instanceof X)
    e.push(n.referencedRule);
  else if (n instanceof j || n instanceof K || n instanceof me || n instanceof Ae || n instanceof le || n instanceof U)
    e = e.concat(Ut(n.definition));
  else if (n instanceof he)
    e = ie(A(n.definition, (i) => Ut(i.definition)));
  else if (!(n instanceof M)) throw Error("non exhaustive match");
  const r = Bt(n), s = t.length > 1;
  if (r && s) {
    const i = F(t);
    return e.concat(Ut(i));
  } else
    return e;
}
class fr extends Je {
  constructor() {
    super(...arguments), this.alternations = [];
  }
  visitAlternation(e) {
    this.alternations.push(e);
  }
}
function Jf(t, e) {
  const n = new fr();
  t.accept(n);
  const r = n.alternations;
  return Q(r, (i) => {
    const a = Et(i.definition);
    return Q(a, (o, c) => {
      const u = fi([o], [], It, 1);
      return v(u) ? [
        {
          message: e.buildEmptyAlternationError({
            topLevelRule: t,
            alternation: i,
            emptyChoiceIdx: c
          }),
          type: B.NONE_LAST_EMPTY_ALT,
          ruleName: t.name,
          occurrence: i.idx,
          alternative: c + 1
        }
      ] : [];
    });
  });
}
function ed(t, e, n) {
  const r = new fr();
  t.accept(r);
  let s = r.alternations;
  return s = cn(s, (a) => a.ignoreAmbiguities === !0), Q(s, (a) => {
    const o = a.idx, c = a.maxLookahead || e, u = lr(o, t, c, a), l = sd(u, a, t, n), h = id(u, a, t, n);
    return l.concat(h);
  });
}
class td extends Je {
  constructor() {
    super(...arguments), this.allProductions = [];
  }
  visitRepetitionWithSeparator(e) {
    this.allProductions.push(e);
  }
  visitRepetitionMandatory(e) {
    this.allProductions.push(e);
  }
  visitRepetitionMandatoryWithSeparator(e) {
    this.allProductions.push(e);
  }
  visitRepetition(e) {
    this.allProductions.push(e);
  }
}
function nd(t, e) {
  const n = new fr();
  t.accept(n);
  const r = n.alternations;
  return Q(r, (i) => i.definition.length > 255 ? [
    {
      message: e.buildTooManyAlternativesError({
        topLevelRule: t,
        alternation: i
      }),
      type: B.TOO_MANY_ALTS,
      ruleName: t.name,
      occurrence: i.idx
    }
  ] : []);
}
function rd(t, e, n) {
  const r = [];
  return S(t, (s) => {
    const i = new td();
    s.accept(i);
    const a = i.allProductions;
    S(a, (o) => {
      const c = di(o), u = o.maxLookahead || e, l = o.idx, f = hr(l, s, c, u)[0];
      if (v(ie(f))) {
        const p = n.buildEmptyRepetitionError({
          topLevelRule: s,
          repetition: o
        });
        r.push({
          message: p,
          type: B.NO_NON_EMPTY_LOOKAHEAD,
          ruleName: s.name
        });
      }
    });
  }), r;
}
function sd(t, e, n, r) {
  const s = [], i = Y(t, (o, c, u) => (e.definition[u].ignoreAmbiguities === !0 || S(c, (l) => {
    const h = [u];
    S(t, (f, p) => {
      u !== p && kn(f, l) && // ignore (skip) ambiguities with this "other" alternative
      e.definition[p].ignoreAmbiguities !== !0 && h.push(p);
    }), h.length > 1 && !kn(s, l) && (s.push(l), o.push({
      alts: h,
      path: l
    }));
  }), o), []);
  return A(i, (o) => {
    const c = A(o.alts, (l) => l + 1);
    return {
      message: r.buildAlternationAmbiguityError({
        topLevelRule: n,
        alternation: e,
        ambiguityIndices: c,
        prefixPath: o.path
      }),
      type: B.AMBIGUOUS_ALTS,
      ruleName: n.name,
      occurrence: e.idx,
      alternatives: o.alts
    };
  });
}
function id(t, e, n, r) {
  const s = Y(t, (a, o, c) => {
    const u = A(o, (l) => ({ idx: c, path: l }));
    return a.concat(u);
  }, []);
  return At(Q(s, (a) => {
    if (e.definition[a.idx].ignoreAmbiguities === !0)
      return [];
    const c = a.idx, u = a.path, l = ne(s, (f) => (
      // ignore (skip) ambiguities with this "other" alternative
      e.definition[f.idx].ignoreAmbiguities !== !0 && f.idx < c && // checking for strict prefix because identical lookaheads
      // will be be detected using a different validation.
      jf(f.path, u)
    ));
    return A(l, (f) => {
      const p = [f.idx + 1, c + 1], T = e.idx === 0 ? "" : e.idx;
      return {
        message: r.buildAlternationPrefixAmbiguityError({
          topLevelRule: n,
          alternation: e,
          ambiguityIndices: p,
          prefixPath: f.path
        }),
        type: B.AMBIGUOUS_PREFIX_ALTS,
        ruleName: n.name,
        occurrence: T,
        alternatives: p
      };
    });
  }));
}
function ad(t, e, n) {
  const r = [], s = A(e, (i) => i.name);
  return S(t, (i) => {
    const a = i.name;
    if (H(s, a)) {
      const o = n.buildNamespaceConflictError(i);
      r.push({
        message: o,
        type: B.CONFLICT_TOKENS_RULES_NAMESPACE,
        ruleName: a
      });
    }
  }), r;
}
function od(t) {
  const e = ir(t, {
    errMsgProvider: Mf
  }), n = {};
  return S(t.rules, (r) => {
    n[r.name] = r;
  }), kf(n, e.errMsgProvider);
}
function cd(t) {
  return t = ir(t, {
    errMsgProvider: De
  }), Vf(t.rules, t.tokenTypes, t.errMsgProvider, t.grammarName);
}
const Ai = "MismatchedTokenException", Ri = "NoViableAltException", Ii = "EarlyExitException", Si = "NotAllInputParsedException", _i = [
  Ai,
  Ri,
  Ii,
  Si
];
Object.freeze(_i);
function zt(t) {
  return H(_i, t.name);
}
class fn extends Error {
  constructor(e, n) {
    super(e), this.token = n, this.resyncedTokens = [], Object.setPrototypeOf(this, new.target.prototype), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
  }
}
class Oi extends fn {
  constructor(e, n, r) {
    super(e, n), this.previousToken = r, this.name = Ai;
  }
}
class ud extends fn {
  constructor(e, n, r) {
    super(e, n), this.previousToken = r, this.name = Ri;
  }
}
class ld extends fn {
  constructor(e, n) {
    super(e, n), this.name = Si;
  }
}
class hd extends fn {
  constructor(e, n, r) {
    super(e, n), this.previousToken = r, this.name = Ii;
  }
}
const Sn = {}, Ni = "InRuleRecoveryException";
class fd extends Error {
  constructor(e) {
    super(e), this.name = Ni;
  }
}
class dd {
  initRecoverable(e) {
    this.firstAfterRepMap = {}, this.resyncFollows = {}, this.recoveryEnabled = R(e, "recoveryEnabled") ? e.recoveryEnabled : Oe.recoveryEnabled, this.recoveryEnabled && (this.attemptInRepetitionRecovery = pd);
  }
  getTokenToInsert(e) {
    const n = ur(e, "", NaN, NaN, NaN, NaN, NaN, NaN);
    return n.isInsertedInRecovery = !0, n;
  }
  canTokenTypeBeInsertedInRecovery(e) {
    return !0;
  }
  canTokenTypeBeDeletedInRecovery(e) {
    return !0;
  }
  tryInRepetitionRecovery(e, n, r, s) {
    const i = this.findReSyncTokenType(), a = this.exportLexerState(), o = [];
    let c = !1;
    const u = this.LA(1);
    let l = this.LA(1);
    const h = () => {
      const f = this.LA(0), p = this.errorMessageProvider.buildMismatchTokenMessage({
        expected: s,
        actual: u,
        previous: f,
        ruleName: this.getCurrRuleFullName()
      }), T = new Oi(p, u, this.LA(0));
      T.resyncedTokens = Et(o), this.SAVE_ERROR(T);
    };
    for (; !c; )
      if (this.tokenMatcher(l, s)) {
        h();
        return;
      } else if (r.call(this)) {
        h(), e.apply(this, n);
        return;
      } else this.tokenMatcher(l, i) ? c = !0 : (l = this.SKIP_TOKEN(), this.addToResyncTokens(l, o));
    this.importLexerState(a);
  }
  shouldInRepetitionRecoveryBeTried(e, n, r) {
    return !(r === !1 || this.tokenMatcher(this.LA(1), e) || this.isBackTracking() || this.canPerformInRuleRecovery(e, this.getFollowsForInRuleRecovery(e, n)));
  }
  // Error Recovery functionality
  getFollowsForInRuleRecovery(e, n) {
    const r = this.getCurrentGrammarPath(e, n);
    return this.getNextPossibleTokenTypes(r);
  }
  tryInRuleRecovery(e, n) {
    if (this.canRecoverWithSingleTokenInsertion(e, n))
      return this.getTokenToInsert(e);
    if (this.canRecoverWithSingleTokenDeletion(e)) {
      const r = this.SKIP_TOKEN();
      return this.consumeToken(), r;
    }
    throw new fd("sad sad panda");
  }
  canPerformInRuleRecovery(e, n) {
    return this.canRecoverWithSingleTokenInsertion(e, n) || this.canRecoverWithSingleTokenDeletion(e);
  }
  canRecoverWithSingleTokenInsertion(e, n) {
    if (!this.canTokenTypeBeInsertedInRecovery(e) || v(n))
      return !1;
    const r = this.LA(1);
    return Ze(n, (i) => this.tokenMatcher(r, i)) !== void 0;
  }
  canRecoverWithSingleTokenDeletion(e) {
    return this.canTokenTypeBeDeletedInRecovery(e) ? this.tokenMatcher(this.LA(2), e) : !1;
  }
  isInCurrentRuleReSyncSet(e) {
    const n = this.getCurrFollowKey(), r = this.getFollowSetFromFollowKey(n);
    return H(r, e);
  }
  findReSyncTokenType() {
    const e = this.flattenFollowSet();
    let n = this.LA(1), r = 2;
    for (; ; ) {
      const s = Ze(e, (i) => Pf(n, i));
      if (s !== void 0)
        return s;
      n = this.LA(r), r++;
    }
  }
  getCurrFollowKey() {
    if (this.RULE_STACK.length === 1)
      return Sn;
    const e = this.getLastExplicitRuleShortName(), n = this.getLastExplicitRuleOccurrenceIndex(), r = this.getPreviousExplicitRuleShortName();
    return {
      ruleName: this.shortRuleNameToFullName(e),
      idxInCallingRule: n,
      inRule: this.shortRuleNameToFullName(r)
    };
  }
  buildFullFollowKeyStack() {
    const e = this.RULE_STACK, n = this.RULE_OCCURRENCE_STACK;
    return A(e, (r, s) => s === 0 ? Sn : {
      ruleName: this.shortRuleNameToFullName(r),
      idxInCallingRule: n[s],
      inRule: this.shortRuleNameToFullName(e[s - 1])
    });
  }
  flattenFollowSet() {
    const e = A(this.buildFullFollowKeyStack(), (n) => this.getFollowSetFromFollowKey(n));
    return ie(e);
  }
  getFollowSetFromFollowKey(e) {
    if (e === Sn)
      return [Be];
    const n = e.ruleName + e.idxInCallingRule + ti + e.inRule;
    return this.resyncFollows[n];
  }
  // It does not make any sense to include a virtual EOF token in the list of resynced tokens
  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)
  addToResyncTokens(e, n) {
    return this.tokenMatcher(e, Be) || n.push(e), n;
  }
  reSyncTo(e) {
    const n = [];
    let r = this.LA(1);
    for (; this.tokenMatcher(r, e) === !1; )
      r = this.SKIP_TOKEN(), this.addToResyncTokens(r, n);
    return Et(n);
  }
  attemptInRepetitionRecovery(e, n, r, s, i, a, o) {
  }
  getCurrentGrammarPath(e, n) {
    const r = this.getHumanReadableRuleStack(), s = D(this.RULE_OCCURRENCE_STACK);
    return {
      ruleStack: r,
      occurrenceStack: s,
      lastTok: e,
      lastTokOccurrence: n
    };
  }
  getHumanReadableRuleStack() {
    return A(this.RULE_STACK, (e) => this.shortRuleNameToFullName(e));
  }
}
function pd(t, e, n, r, s, i, a) {
  const o = this.getKeyForAutomaticLookahead(r, s);
  let c = this.firstAfterRepMap[o];
  if (c === void 0) {
    const f = this.getCurrRuleFullName(), p = this.getGAstProductions()[f];
    c = new i(p, s).startWalking(), this.firstAfterRepMap[o] = c;
  }
  let u = c.token, l = c.occurrence;
  const h = c.isEndOfRule;
  this.RULE_STACK.length === 1 && h && u === void 0 && (u = Be, l = 1), !(u === void 0 || l === void 0) && this.shouldInRepetitionRecoveryBeTried(u, l, a) && this.tryInRepetitionRecovery(t, e, n, u);
}
const Ed = 4, we = 8, Ci = 1 << we, Li = 2 << we, xn = 3 << we, bn = 4 << we, wn = 5 << we, Ft = 6 << we;
function _n(t, e, n) {
  return n | e | t;
}
class gd {
  constructor(e) {
    var n;
    this.maxLookahead = (n = e?.maxLookahead) !== null && n !== void 0 ? n : Oe.maxLookahead;
  }
  validate(e) {
    const n = this.validateNoLeftRecursion(e.rules);
    if (v(n)) {
      const r = this.validateEmptyOrAlternatives(e.rules), s = this.validateAmbiguousAlternationAlternatives(e.rules, this.maxLookahead), i = this.validateSomeNonEmptyLookaheadPath(e.rules, this.maxLookahead);
      return [
        ...n,
        ...r,
        ...s,
        ...i
      ];
    }
    return n;
  }
  validateNoLeftRecursion(e) {
    return Q(e, (n) => mi(n, n, De));
  }
  validateEmptyOrAlternatives(e) {
    return Q(e, (n) => Jf(n, De));
  }
  validateAmbiguousAlternationAlternatives(e, n) {
    return Q(e, (r) => ed(r, n, De));
  }
  validateSomeNonEmptyLookaheadPath(e, n) {
    return rd(e, n, De);
  }
  buildLookaheadForAlternation(e) {
    return $f(e.prodOccurrence, e.rule, e.maxLookahead, e.hasPredicates, e.dynamicTokensEnabled, Bf);
  }
  buildLookaheadForOptional(e) {
    return Gf(e.prodOccurrence, e.rule, e.maxLookahead, e.dynamicTokensEnabled, di(e.prodType), Hf);
  }
}
class Td {
  initLooksAhead(e) {
    this.dynamicTokensEnabled = R(e, "dynamicTokensEnabled") ? e.dynamicTokensEnabled : Oe.dynamicTokensEnabled, this.maxLookahead = R(e, "maxLookahead") ? e.maxLookahead : Oe.maxLookahead, this.lookaheadStrategy = R(e, "lookaheadStrategy") ? e.lookaheadStrategy : new gd({ maxLookahead: this.maxLookahead }), this.lookAheadFuncsCache = /* @__PURE__ */ new Map();
  }
  preComputeLookaheadFunctions(e) {
    S(e, (n) => {
      this.TRACE_INIT(`${n.name} Rule Lookahead`, () => {
        const { alternation: r, repetition: s, option: i, repetitionMandatory: a, repetitionMandatoryWithSeparator: o, repetitionWithSeparator: c } = Ad(n);
        S(r, (u) => {
          const l = u.idx === 0 ? "" : u.idx;
          this.TRACE_INIT(`${fe(u)}${l}`, () => {
            const h = this.lookaheadStrategy.buildLookaheadForAlternation({
              prodOccurrence: u.idx,
              rule: n,
              maxLookahead: u.maxLookahead || this.maxLookahead,
              hasPredicates: u.hasPredicates,
              dynamicTokensEnabled: this.dynamicTokensEnabled
            }), f = _n(this.fullRuleNameToShort[n.name], Ci, u.idx);
            this.setLaFuncCache(f, h);
          });
        }), S(s, (u) => {
          this.computeLookaheadFunc(n, u.idx, xn, "Repetition", u.maxLookahead, fe(u));
        }), S(i, (u) => {
          this.computeLookaheadFunc(n, u.idx, Li, "Option", u.maxLookahead, fe(u));
        }), S(a, (u) => {
          this.computeLookaheadFunc(n, u.idx, bn, "RepetitionMandatory", u.maxLookahead, fe(u));
        }), S(o, (u) => {
          this.computeLookaheadFunc(n, u.idx, Ft, "RepetitionMandatoryWithSeparator", u.maxLookahead, fe(u));
        }), S(c, (u) => {
          this.computeLookaheadFunc(n, u.idx, wn, "RepetitionWithSeparator", u.maxLookahead, fe(u));
        });
      });
    });
  }
  computeLookaheadFunc(e, n, r, s, i, a) {
    this.TRACE_INIT(`${a}${n === 0 ? "" : n}`, () => {
      const o = this.lookaheadStrategy.buildLookaheadForOptional({
        prodOccurrence: n,
        rule: e,
        maxLookahead: i || this.maxLookahead,
        dynamicTokensEnabled: this.dynamicTokensEnabled,
        prodType: s
      }), c = _n(this.fullRuleNameToShort[e.name], r, n);
      this.setLaFuncCache(c, o);
    });
  }
  // this actually returns a number, but it is always used as a string (object prop key)
  getKeyForAutomaticLookahead(e, n) {
    const r = this.getLastExplicitRuleShortName();
    return _n(r, e, n);
  }
  getLaFuncFromCache(e) {
    return this.lookAheadFuncsCache.get(e);
  }
  /* istanbul ignore next */
  setLaFuncCache(e, n) {
    this.lookAheadFuncsCache.set(e, n);
  }
}
class md extends Je {
  constructor() {
    super(...arguments), this.dslMethods = {
      option: [],
      alternation: [],
      repetition: [],
      repetitionWithSeparator: [],
      repetitionMandatory: [],
      repetitionMandatoryWithSeparator: []
    };
  }
  reset() {
    this.dslMethods = {
      option: [],
      alternation: [],
      repetition: [],
      repetitionWithSeparator: [],
      repetitionMandatory: [],
      repetitionMandatoryWithSeparator: []
    };
  }
  visitOption(e) {
    this.dslMethods.option.push(e);
  }
  visitRepetitionWithSeparator(e) {
    this.dslMethods.repetitionWithSeparator.push(e);
  }
  visitRepetitionMandatory(e) {
    this.dslMethods.repetitionMandatory.push(e);
  }
  visitRepetitionMandatoryWithSeparator(e) {
    this.dslMethods.repetitionMandatoryWithSeparator.push(e);
  }
  visitRepetition(e) {
    this.dslMethods.repetition.push(e);
  }
  visitAlternation(e) {
    this.dslMethods.alternation.push(e);
  }
}
const Pt = new md();
function Ad(t) {
  Pt.reset(), t.accept(Pt);
  const e = Pt.dslMethods;
  return Pt.reset(), e;
}
function Ts(t, e) {
  isNaN(t.startOffset) === !0 ? (t.startOffset = e.startOffset, t.endOffset = e.endOffset) : t.endOffset < e.endOffset && (t.endOffset = e.endOffset);
}
function ms(t, e) {
  isNaN(t.startOffset) === !0 ? (t.startOffset = e.startOffset, t.startColumn = e.startColumn, t.startLine = e.startLine, t.endOffset = e.endOffset, t.endColumn = e.endColumn, t.endLine = e.endLine) : t.endOffset < e.endOffset && (t.endOffset = e.endOffset, t.endColumn = e.endColumn, t.endLine = e.endLine);
}
function Rd(t, e, n) {
  t.children[n] === void 0 ? t.children[n] = [e] : t.children[n].push(e);
}
function Id(t, e, n) {
  t.children[e] === void 0 ? t.children[e] = [n] : t.children[e].push(n);
}
const Sd = "name";
function yi(t, e) {
  Object.defineProperty(t, Sd, {
    enumerable: !1,
    configurable: !0,
    writable: !1,
    value: e
  });
}
function _d(t, e) {
  const n = te(t), r = n.length;
  for (let s = 0; s < r; s++) {
    const i = n[s], a = t[i], o = a.length;
    for (let c = 0; c < o; c++) {
      const u = a[c];
      u.tokenTypeIdx === void 0 && this[u.name](u.children, e);
    }
  }
}
function Od(t, e) {
  const n = function() {
  };
  yi(n, t + "BaseSemantics");
  const r = {
    visit: function(s, i) {
      if (N(s) && (s = s[0]), !_e(s))
        return this[s.name](s.children, i);
    },
    validateVisitor: function() {
      const s = Cd(this, e);
      if (!v(s)) {
        const i = A(s, (a) => a.msg);
        throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:
	${i.join(`

`).replace(/\n/g, `
	`)}`);
      }
    }
  };
  return n.prototype = r, n.prototype.constructor = n, n._RULE_NAMES = e, n;
}
function Nd(t, e, n) {
  const r = function() {
  };
  yi(r, t + "BaseSemanticsWithDefaults");
  const s = Object.create(n.prototype);
  return S(e, (i) => {
    s[i] = _d;
  }), r.prototype = s, r.prototype.constructor = r, r;
}
var Un;
(function(t) {
  t[t.REDUNDANT_METHOD = 0] = "REDUNDANT_METHOD", t[t.MISSING_METHOD = 1] = "MISSING_METHOD";
})(Un || (Un = {}));
function Cd(t, e) {
  return Ld(t, e);
}
function Ld(t, e) {
  const n = ne(e, (s) => Ne(t[s]) === !1), r = A(n, (s) => ({
    msg: `Missing visitor method: <${s}> on ${t.constructor.name} CST Visitor.`,
    type: Un.MISSING_METHOD,
    methodName: s
  }));
  return At(r);
}
class yd {
  initTreeBuilder(e) {
    if (this.CST_STACK = [], this.outputCst = e.outputCst, this.nodeLocationTracking = R(e, "nodeLocationTracking") ? e.nodeLocationTracking : Oe.nodeLocationTracking, !this.outputCst)
      this.cstInvocationStateUpdate = b, this.cstFinallyStateUpdate = b, this.cstPostTerminal = b, this.cstPostNonTerminal = b, this.cstPostRule = b;
    else if (/full/i.test(this.nodeLocationTracking))
      this.recoveryEnabled ? (this.setNodeLocationFromToken = ms, this.setNodeLocationFromNode = ms, this.cstPostRule = b, this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery) : (this.setNodeLocationFromToken = b, this.setNodeLocationFromNode = b, this.cstPostRule = this.cstPostRuleFull, this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular);
    else if (/onlyOffset/i.test(this.nodeLocationTracking))
      this.recoveryEnabled ? (this.setNodeLocationFromToken = Ts, this.setNodeLocationFromNode = Ts, this.cstPostRule = b, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery) : (this.setNodeLocationFromToken = b, this.setNodeLocationFromNode = b, this.cstPostRule = this.cstPostRuleOnlyOffset, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular);
    else if (/none/i.test(this.nodeLocationTracking))
      this.setNodeLocationFromToken = b, this.setNodeLocationFromNode = b, this.cstPostRule = b, this.setInitialNodeLocation = b;
    else
      throw Error(`Invalid <nodeLocationTracking> config option: "${e.nodeLocationTracking}"`);
  }
  setInitialNodeLocationOnlyOffsetRecovery(e) {
    e.location = {
      startOffset: NaN,
      endOffset: NaN
    };
  }
  setInitialNodeLocationOnlyOffsetRegular(e) {
    e.location = {
      // without error recovery the starting Location of a new CstNode is guaranteed
      // To be the next Token's startOffset (for valid inputs).
      // For invalid inputs there won't be any CSTOutput so this potential
      // inaccuracy does not matter
      startOffset: this.LA(1).startOffset,
      endOffset: NaN
    };
  }
  setInitialNodeLocationFullRecovery(e) {
    e.location = {
      startOffset: NaN,
      startLine: NaN,
      startColumn: NaN,
      endOffset: NaN,
      endLine: NaN,
      endColumn: NaN
    };
  }
  /**
       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work
  
       * @param cstNode
       */
  setInitialNodeLocationFullRegular(e) {
    const n = this.LA(1);
    e.location = {
      startOffset: n.startOffset,
      startLine: n.startLine,
      startColumn: n.startColumn,
      endOffset: NaN,
      endLine: NaN,
      endColumn: NaN
    };
  }
  cstInvocationStateUpdate(e) {
    const n = {
      name: e,
      children: /* @__PURE__ */ Object.create(null)
    };
    this.setInitialNodeLocation(n), this.CST_STACK.push(n);
  }
  cstFinallyStateUpdate() {
    this.CST_STACK.pop();
  }
  cstPostRuleFull(e) {
    const n = this.LA(0), r = e.location;
    r.startOffset <= n.startOffset ? (r.endOffset = n.endOffset, r.endLine = n.endLine, r.endColumn = n.endColumn) : (r.startOffset = NaN, r.startLine = NaN, r.startColumn = NaN);
  }
  cstPostRuleOnlyOffset(e) {
    const n = this.LA(0), r = e.location;
    r.startOffset <= n.startOffset ? r.endOffset = n.endOffset : r.startOffset = NaN;
  }
  cstPostTerminal(e, n) {
    const r = this.CST_STACK[this.CST_STACK.length - 1];
    Rd(r, n, e), this.setNodeLocationFromToken(r.location, n);
  }
  cstPostNonTerminal(e, n) {
    const r = this.CST_STACK[this.CST_STACK.length - 1];
    Id(r, n, e), this.setNodeLocationFromNode(r.location, e.location);
  }
  getBaseCstVisitorConstructor() {
    if (_e(this.baseCstVisitorConstructor)) {
      const e = Od(this.className, te(this.gastProductionsCache));
      return this.baseCstVisitorConstructor = e, e;
    }
    return this.baseCstVisitorConstructor;
  }
  getBaseCstVisitorConstructorWithDefaults() {
    if (_e(this.baseCstVisitorWithDefaultsConstructor)) {
      const e = Nd(this.className, te(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
      return this.baseCstVisitorWithDefaultsConstructor = e, e;
    }
    return this.baseCstVisitorWithDefaultsConstructor;
  }
  getLastExplicitRuleShortName() {
    const e = this.RULE_STACK;
    return e[e.length - 1];
  }
  getPreviousExplicitRuleShortName() {
    const e = this.RULE_STACK;
    return e[e.length - 2];
  }
  getLastExplicitRuleOccurrenceIndex() {
    const e = this.RULE_OCCURRENCE_STACK;
    return e[e.length - 1];
  }
}
class vd {
  initLexerAdapter() {
    this.tokVector = [], this.tokVectorLength = 0, this.currIdx = -1;
  }
  set input(e) {
    if (this.selfAnalysisDone !== !0)
      throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
    this.reset(), this.tokVector = e, this.tokVectorLength = e.length;
  }
  get input() {
    return this.tokVector;
  }
  // skips a token and returns the next token
  SKIP_TOKEN() {
    return this.currIdx <= this.tokVector.length - 2 ? (this.consumeToken(), this.LA(1)) : Yt;
  }
  // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers
  // or lexers dependent on parser context.
  LA(e) {
    const n = this.currIdx + e;
    return n < 0 || this.tokVectorLength <= n ? Yt : this.tokVector[n];
  }
  consumeToken() {
    this.currIdx++;
  }
  exportLexerState() {
    return this.currIdx;
  }
  importLexerState(e) {
    this.currIdx = e;
  }
  resetLexerState() {
    this.currIdx = -1;
  }
  moveToTerminatedState() {
    this.currIdx = this.tokVector.length - 1;
  }
  getLexerPosition() {
    return this.exportLexerState();
  }
}
class Pd {
  ACTION(e) {
    return e.call(this);
  }
  consume(e, n, r) {
    return this.consumeInternal(n, e, r);
  }
  subrule(e, n, r) {
    return this.subruleInternal(n, e, r);
  }
  option(e, n) {
    return this.optionInternal(n, e);
  }
  or(e, n) {
    return this.orInternal(n, e);
  }
  many(e, n) {
    return this.manyInternal(e, n);
  }
  atLeastOne(e, n) {
    return this.atLeastOneInternal(e, n);
  }
  CONSUME(e, n) {
    return this.consumeInternal(e, 0, n);
  }
  CONSUME1(e, n) {
    return this.consumeInternal(e, 1, n);
  }
  CONSUME2(e, n) {
    return this.consumeInternal(e, 2, n);
  }
  CONSUME3(e, n) {
    return this.consumeInternal(e, 3, n);
  }
  CONSUME4(e, n) {
    return this.consumeInternal(e, 4, n);
  }
  CONSUME5(e, n) {
    return this.consumeInternal(e, 5, n);
  }
  CONSUME6(e, n) {
    return this.consumeInternal(e, 6, n);
  }
  CONSUME7(e, n) {
    return this.consumeInternal(e, 7, n);
  }
  CONSUME8(e, n) {
    return this.consumeInternal(e, 8, n);
  }
  CONSUME9(e, n) {
    return this.consumeInternal(e, 9, n);
  }
  SUBRULE(e, n) {
    return this.subruleInternal(e, 0, n);
  }
  SUBRULE1(e, n) {
    return this.subruleInternal(e, 1, n);
  }
  SUBRULE2(e, n) {
    return this.subruleInternal(e, 2, n);
  }
  SUBRULE3(e, n) {
    return this.subruleInternal(e, 3, n);
  }
  SUBRULE4(e, n) {
    return this.subruleInternal(e, 4, n);
  }
  SUBRULE5(e, n) {
    return this.subruleInternal(e, 5, n);
  }
  SUBRULE6(e, n) {
    return this.subruleInternal(e, 6, n);
  }
  SUBRULE7(e, n) {
    return this.subruleInternal(e, 7, n);
  }
  SUBRULE8(e, n) {
    return this.subruleInternal(e, 8, n);
  }
  SUBRULE9(e, n) {
    return this.subruleInternal(e, 9, n);
  }
  OPTION(e) {
    return this.optionInternal(e, 0);
  }
  OPTION1(e) {
    return this.optionInternal(e, 1);
  }
  OPTION2(e) {
    return this.optionInternal(e, 2);
  }
  OPTION3(e) {
    return this.optionInternal(e, 3);
  }
  OPTION4(e) {
    return this.optionInternal(e, 4);
  }
  OPTION5(e) {
    return this.optionInternal(e, 5);
  }
  OPTION6(e) {
    return this.optionInternal(e, 6);
  }
  OPTION7(e) {
    return this.optionInternal(e, 7);
  }
  OPTION8(e) {
    return this.optionInternal(e, 8);
  }
  OPTION9(e) {
    return this.optionInternal(e, 9);
  }
  OR(e) {
    return this.orInternal(e, 0);
  }
  OR1(e) {
    return this.orInternal(e, 1);
  }
  OR2(e) {
    return this.orInternal(e, 2);
  }
  OR3(e) {
    return this.orInternal(e, 3);
  }
  OR4(e) {
    return this.orInternal(e, 4);
  }
  OR5(e) {
    return this.orInternal(e, 5);
  }
  OR6(e) {
    return this.orInternal(e, 6);
  }
  OR7(e) {
    return this.orInternal(e, 7);
  }
  OR8(e) {
    return this.orInternal(e, 8);
  }
  OR9(e) {
    return this.orInternal(e, 9);
  }
  MANY(e) {
    this.manyInternal(0, e);
  }
  MANY1(e) {
    this.manyInternal(1, e);
  }
  MANY2(e) {
    this.manyInternal(2, e);
  }
  MANY3(e) {
    this.manyInternal(3, e);
  }
  MANY4(e) {
    this.manyInternal(4, e);
  }
  MANY5(e) {
    this.manyInternal(5, e);
  }
  MANY6(e) {
    this.manyInternal(6, e);
  }
  MANY7(e) {
    this.manyInternal(7, e);
  }
  MANY8(e) {
    this.manyInternal(8, e);
  }
  MANY9(e) {
    this.manyInternal(9, e);
  }
  MANY_SEP(e) {
    this.manySepFirstInternal(0, e);
  }
  MANY_SEP1(e) {
    this.manySepFirstInternal(1, e);
  }
  MANY_SEP2(e) {
    this.manySepFirstInternal(2, e);
  }
  MANY_SEP3(e) {
    this.manySepFirstInternal(3, e);
  }
  MANY_SEP4(e) {
    this.manySepFirstInternal(4, e);
  }
  MANY_SEP5(e) {
    this.manySepFirstInternal(5, e);
  }
  MANY_SEP6(e) {
    this.manySepFirstInternal(6, e);
  }
  MANY_SEP7(e) {
    this.manySepFirstInternal(7, e);
  }
  MANY_SEP8(e) {
    this.manySepFirstInternal(8, e);
  }
  MANY_SEP9(e) {
    this.manySepFirstInternal(9, e);
  }
  AT_LEAST_ONE(e) {
    this.atLeastOneInternal(0, e);
  }
  AT_LEAST_ONE1(e) {
    return this.atLeastOneInternal(1, e);
  }
  AT_LEAST_ONE2(e) {
    this.atLeastOneInternal(2, e);
  }
  AT_LEAST_ONE3(e) {
    this.atLeastOneInternal(3, e);
  }
  AT_LEAST_ONE4(e) {
    this.atLeastOneInternal(4, e);
  }
  AT_LEAST_ONE5(e) {
    this.atLeastOneInternal(5, e);
  }
  AT_LEAST_ONE6(e) {
    this.atLeastOneInternal(6, e);
  }
  AT_LEAST_ONE7(e) {
    this.atLeastOneInternal(7, e);
  }
  AT_LEAST_ONE8(e) {
    this.atLeastOneInternal(8, e);
  }
  AT_LEAST_ONE9(e) {
    this.atLeastOneInternal(9, e);
  }
  AT_LEAST_ONE_SEP(e) {
    this.atLeastOneSepFirstInternal(0, e);
  }
  AT_LEAST_ONE_SEP1(e) {
    this.atLeastOneSepFirstInternal(1, e);
  }
  AT_LEAST_ONE_SEP2(e) {
    this.atLeastOneSepFirstInternal(2, e);
  }
  AT_LEAST_ONE_SEP3(e) {
    this.atLeastOneSepFirstInternal(3, e);
  }
  AT_LEAST_ONE_SEP4(e) {
    this.atLeastOneSepFirstInternal(4, e);
  }
  AT_LEAST_ONE_SEP5(e) {
    this.atLeastOneSepFirstInternal(5, e);
  }
  AT_LEAST_ONE_SEP6(e) {
    this.atLeastOneSepFirstInternal(6, e);
  }
  AT_LEAST_ONE_SEP7(e) {
    this.atLeastOneSepFirstInternal(7, e);
  }
  AT_LEAST_ONE_SEP8(e) {
    this.atLeastOneSepFirstInternal(8, e);
  }
  AT_LEAST_ONE_SEP9(e) {
    this.atLeastOneSepFirstInternal(9, e);
  }
  RULE(e, n, r = Xt) {
    if (H(this.definedRulesNames, e)) {
      const a = {
        message: De.buildDuplicateRuleNameError({
          topLevelRule: e,
          grammarName: this.className
        }),
        type: B.DUPLICATE_RULE_NAME,
        ruleName: e
      };
      this.definitionErrors.push(a);
    }
    this.definedRulesNames.push(e);
    const s = this.defineRule(e, n, r);
    return this[e] = s, s;
  }
  OVERRIDE_RULE(e, n, r = Xt) {
    const s = Qf(e, this.definedRulesNames, this.className);
    this.definitionErrors = this.definitionErrors.concat(s);
    const i = this.defineRule(e, n, r);
    return this[e] = i, i;
  }
  BACKTRACK(e, n) {
    return function() {
      this.isBackTrackingStack.push(1);
      const r = this.saveRecogState();
      try {
        return e.apply(this, n), !0;
      } catch (s) {
        if (zt(s))
          return !1;
        throw s;
      } finally {
        this.reloadRecogState(r), this.isBackTrackingStack.pop();
      }
    };
  }
  // GAST export APIs
  getGAstProductions() {
    return this.gastProductionsCache;
  }
  getSerializedGastProductions() {
    return Mh(w(this.gastProductionsCache));
  }
}
class Md {
  initRecognizerEngine(e, n) {
    if (this.className = this.constructor.name, this.shortRuleNameToFull = {}, this.fullRuleNameToShort = {}, this.ruleShortNameIdx = 256, this.tokenMatcher = jt, this.subruleIdx = 0, this.definedRulesNames = [], this.tokensMap = {}, this.isBackTrackingStack = [], this.RULE_STACK = [], this.RULE_OCCURRENCE_STACK = [], this.gastProductionsCache = {}, R(n, "serializedGrammar"))
      throw Error(`The Parser's configuration can no longer contain a <serializedGrammar> property.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0
	For Further details.`);
    if (N(e)) {
      if (v(e))
        throw Error(`A Token Vocabulary cannot be empty.
	Note that the first argument for the parser constructor
	is no longer a Token vector (since v4.0).`);
      if (typeof e[0].startOffset == "number")
        throw Error(`The Parser constructor no longer accepts a token vector as the first argument.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0
	For Further details.`);
    }
    if (N(e))
      this.tokensMap = Y(e, (i, a) => (i[a.name] = a, i), {});
    else if (R(e, "modes") && ae(ie(w(e.modes)), Cf)) {
      const i = ie(w(e.modes)), a = ar(i);
      this.tokensMap = Y(a, (o, c) => (o[c.name] = c, o), {});
    } else if (ee(e))
      this.tokensMap = D(e);
    else
      throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
    this.tokensMap.EOF = Be;
    const r = R(e, "modes") ? ie(w(e.modes)) : w(e), s = ae(r, (i) => v(i.categoryMatches));
    this.tokenMatcher = s ? jt : It, St(w(this.tokensMap));
  }
  defineRule(e, n, r) {
    if (this.selfAnalysisDone)
      throw Error(`Grammar rule <${e}> may not be defined after the 'performSelfAnalysis' method has been called'
Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);
    const s = R(r, "resyncEnabled") ? r.resyncEnabled : Xt.resyncEnabled, i = R(r, "recoveryValueFunc") ? r.recoveryValueFunc : Xt.recoveryValueFunc, a = this.ruleShortNameIdx << Ed + we;
    this.ruleShortNameIdx++, this.shortRuleNameToFull[a] = e, this.fullRuleNameToShort[e] = a;
    let o;
    return this.outputCst === !0 ? o = function(...l) {
      try {
        this.ruleInvocationStateUpdate(a, e, this.subruleIdx), n.apply(this, l);
        const h = this.CST_STACK[this.CST_STACK.length - 1];
        return this.cstPostRule(h), h;
      } catch (h) {
        return this.invokeRuleCatch(h, s, i);
      } finally {
        this.ruleFinallyStateUpdate();
      }
    } : o = function(...l) {
      try {
        return this.ruleInvocationStateUpdate(a, e, this.subruleIdx), n.apply(this, l);
      } catch (h) {
        return this.invokeRuleCatch(h, s, i);
      } finally {
        this.ruleFinallyStateUpdate();
      }
    }, Object.assign(o, { ruleName: e, originalGrammarAction: n });
  }
  invokeRuleCatch(e, n, r) {
    const s = this.RULE_STACK.length === 1, i = n && !this.isBackTracking() && this.recoveryEnabled;
    if (zt(e)) {
      const a = e;
      if (i) {
        const o = this.findReSyncTokenType();
        if (this.isInCurrentRuleReSyncSet(o))
          if (a.resyncedTokens = this.reSyncTo(o), this.outputCst) {
            const c = this.CST_STACK[this.CST_STACK.length - 1];
            return c.recoveredNode = !0, c;
          } else
            return r(e);
        else {
          if (this.outputCst) {
            const c = this.CST_STACK[this.CST_STACK.length - 1];
            c.recoveredNode = !0, a.partialCstResult = c;
          }
          throw a;
        }
      } else {
        if (s)
          return this.moveToTerminatedState(), r(e);
        throw a;
      }
    } else
      throw e;
  }
  // Implementation of parsing DSL
  optionInternal(e, n) {
    const r = this.getKeyForAutomaticLookahead(Li, n);
    return this.optionInternalLogic(e, n, r);
  }
  optionInternalLogic(e, n, r) {
    let s = this.getLaFuncFromCache(r), i;
    if (typeof e != "function") {
      i = e.DEF;
      const a = e.GATE;
      if (a !== void 0) {
        const o = s;
        s = () => a.call(this) && o.call(this);
      }
    } else
      i = e;
    if (s.call(this) === !0)
      return i.call(this);
  }
  atLeastOneInternal(e, n) {
    const r = this.getKeyForAutomaticLookahead(bn, e);
    return this.atLeastOneInternalLogic(e, n, r);
  }
  atLeastOneInternalLogic(e, n, r) {
    let s = this.getLaFuncFromCache(r), i;
    if (typeof n != "function") {
      i = n.DEF;
      const a = n.GATE;
      if (a !== void 0) {
        const o = s;
        s = () => a.call(this) && o.call(this);
      }
    } else
      i = n;
    if (s.call(this) === !0) {
      let a = this.doSingleRepetition(i);
      for (; s.call(this) === !0 && a === !0; )
        a = this.doSingleRepetition(i);
    } else
      throw this.raiseEarlyExitException(e, k.REPETITION_MANDATORY, n.ERR_MSG);
    this.attemptInRepetitionRecovery(this.atLeastOneInternal, [e, n], s, bn, e, Ff);
  }
  atLeastOneSepFirstInternal(e, n) {
    const r = this.getKeyForAutomaticLookahead(Ft, e);
    this.atLeastOneSepFirstInternalLogic(e, n, r);
  }
  atLeastOneSepFirstInternalLogic(e, n, r) {
    const s = n.DEF, i = n.SEP;
    if (this.getLaFuncFromCache(r).call(this) === !0) {
      s.call(this);
      const o = () => this.tokenMatcher(this.LA(1), i);
      for (; this.tokenMatcher(this.LA(1), i) === !0; )
        this.CONSUME(i), s.call(this);
      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
        e,
        i,
        o,
        s,
        Es
      ], o, Ft, e, Es);
    } else
      throw this.raiseEarlyExitException(e, k.REPETITION_MANDATORY_WITH_SEPARATOR, n.ERR_MSG);
  }
  manyInternal(e, n) {
    const r = this.getKeyForAutomaticLookahead(xn, e);
    return this.manyInternalLogic(e, n, r);
  }
  manyInternalLogic(e, n, r) {
    let s = this.getLaFuncFromCache(r), i;
    if (typeof n != "function") {
      i = n.DEF;
      const o = n.GATE;
      if (o !== void 0) {
        const c = s;
        s = () => o.call(this) && c.call(this);
      }
    } else
      i = n;
    let a = !0;
    for (; s.call(this) === !0 && a === !0; )
      a = this.doSingleRepetition(i);
    this.attemptInRepetitionRecovery(
      this.manyInternal,
      [e, n],
      s,
      xn,
      e,
      Uf,
      // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
      // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
      // An infinite loop cannot occur as:
      // - Either the lookahead is guaranteed to consume something (Single Token Separator)
      // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
      a
    );
  }
  manySepFirstInternal(e, n) {
    const r = this.getKeyForAutomaticLookahead(wn, e);
    this.manySepFirstInternalLogic(e, n, r);
  }
  manySepFirstInternalLogic(e, n, r) {
    const s = n.DEF, i = n.SEP;
    if (this.getLaFuncFromCache(r).call(this) === !0) {
      s.call(this);
      const o = () => this.tokenMatcher(this.LA(1), i);
      for (; this.tokenMatcher(this.LA(1), i) === !0; )
        this.CONSUME(i), s.call(this);
      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
        e,
        i,
        o,
        s,
        ps
      ], o, wn, e, ps);
    }
  }
  repetitionSepSecondInternal(e, n, r, s, i) {
    for (; r(); )
      this.CONSUME(n), s.call(this);
    this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
      e,
      n,
      r,
      s,
      i
    ], r, Ft, e, i);
  }
  doSingleRepetition(e) {
    const n = this.getLexerPosition();
    return e.call(this), this.getLexerPosition() > n;
  }
  orInternal(e, n) {
    const r = this.getKeyForAutomaticLookahead(Ci, n), s = N(e) ? e : e.DEF, a = this.getLaFuncFromCache(r).call(this, s);
    if (a !== void 0)
      return s[a].ALT.call(this);
    this.raiseNoAltException(n, e.ERR_MSG);
  }
  ruleFinallyStateUpdate() {
    if (this.RULE_STACK.pop(), this.RULE_OCCURRENCE_STACK.pop(), this.cstFinallyStateUpdate(), this.RULE_STACK.length === 0 && this.isAtEndOfInput() === !1) {
      const e = this.LA(1), n = this.errorMessageProvider.buildNotAllInputParsedMessage({
        firstRedundant: e,
        ruleName: this.getCurrRuleFullName()
      });
      this.SAVE_ERROR(new ld(n, e));
    }
  }
  subruleInternal(e, n, r) {
    let s;
    try {
      const i = r !== void 0 ? r.ARGS : void 0;
      return this.subruleIdx = n, s = e.apply(this, i), this.cstPostNonTerminal(s, r !== void 0 && r.LABEL !== void 0 ? r.LABEL : e.ruleName), s;
    } catch (i) {
      throw this.subruleInternalError(i, r, e.ruleName);
    }
  }
  subruleInternalError(e, n, r) {
    throw zt(e) && e.partialCstResult !== void 0 && (this.cstPostNonTerminal(e.partialCstResult, n !== void 0 && n.LABEL !== void 0 ? n.LABEL : r), delete e.partialCstResult), e;
  }
  consumeInternal(e, n, r) {
    let s;
    try {
      const i = this.LA(1);
      this.tokenMatcher(i, e) === !0 ? (this.consumeToken(), s = i) : this.consumeInternalError(e, i, r);
    } catch (i) {
      s = this.consumeInternalRecovery(e, n, i);
    }
    return this.cstPostTerminal(r !== void 0 && r.LABEL !== void 0 ? r.LABEL : e.name, s), s;
  }
  consumeInternalError(e, n, r) {
    let s;
    const i = this.LA(0);
    throw r !== void 0 && r.ERR_MSG ? s = r.ERR_MSG : s = this.errorMessageProvider.buildMismatchTokenMessage({
      expected: e,
      actual: n,
      previous: i,
      ruleName: this.getCurrRuleFullName()
    }), this.SAVE_ERROR(new Oi(s, n, i));
  }
  consumeInternalRecovery(e, n, r) {
    if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
    r.name === "MismatchedTokenException" && !this.isBackTracking()) {
      const s = this.getFollowsForInRuleRecovery(e, n);
      try {
        return this.tryInRuleRecovery(e, s);
      } catch (i) {
        throw i.name === Ni ? r : i;
      }
    } else
      throw r;
  }
  saveRecogState() {
    const e = this.errors, n = D(this.RULE_STACK);
    return {
      errors: e,
      lexerState: this.exportLexerState(),
      RULE_STACK: n,
      CST_STACK: this.CST_STACK
    };
  }
  reloadRecogState(e) {
    this.errors = e.errors, this.importLexerState(e.lexerState), this.RULE_STACK = e.RULE_STACK;
  }
  ruleInvocationStateUpdate(e, n, r) {
    this.RULE_OCCURRENCE_STACK.push(r), this.RULE_STACK.push(e), this.cstInvocationStateUpdate(n);
  }
  isBackTracking() {
    return this.isBackTrackingStack.length !== 0;
  }
  getCurrRuleFullName() {
    const e = this.getLastExplicitRuleShortName();
    return this.shortRuleNameToFull[e];
  }
  shortRuleNameToFullName(e) {
    return this.shortRuleNameToFull[e];
  }
  isAtEndOfInput() {
    return this.tokenMatcher(this.LA(1), Be);
  }
  reset() {
    this.resetLexerState(), this.subruleIdx = 0, this.isBackTrackingStack = [], this.errors = [], this.RULE_STACK = [], this.CST_STACK = [], this.RULE_OCCURRENCE_STACK = [];
  }
}
class kd {
  initErrorHandler(e) {
    this._errors = [], this.errorMessageProvider = R(e, "errorMessageProvider") ? e.errorMessageProvider : Oe.errorMessageProvider;
  }
  SAVE_ERROR(e) {
    if (zt(e))
      return e.context = {
        ruleStack: this.getHumanReadableRuleStack(),
        ruleOccurrenceStack: D(this.RULE_OCCURRENCE_STACK)
      }, this._errors.push(e), e;
    throw Error("Trying to save an Error which is not a RecognitionException");
  }
  get errors() {
    return D(this._errors);
  }
  set errors(e) {
    this._errors = e;
  }
  // TODO: consider caching the error message computed information
  raiseEarlyExitException(e, n, r) {
    const s = this.getCurrRuleFullName(), i = this.getGAstProductions()[s], o = hr(e, i, n, this.maxLookahead)[0], c = [];
    for (let l = 1; l <= this.maxLookahead; l++)
      c.push(this.LA(l));
    const u = this.errorMessageProvider.buildEarlyExitMessage({
      expectedIterationPaths: o,
      actual: c,
      previous: this.LA(0),
      customUserDescription: r,
      ruleName: s
    });
    throw this.SAVE_ERROR(new hd(u, this.LA(1), this.LA(0)));
  }
  // TODO: consider caching the error message computed information
  raiseNoAltException(e, n) {
    const r = this.getCurrRuleFullName(), s = this.getGAstProductions()[r], i = lr(e, s, this.maxLookahead), a = [];
    for (let u = 1; u <= this.maxLookahead; u++)
      a.push(this.LA(u));
    const o = this.LA(0), c = this.errorMessageProvider.buildNoViableAltMessage({
      expectedPathsPerAlt: i,
      actual: a,
      previous: o,
      customUserDescription: n,
      ruleName: this.getCurrRuleFullName()
    });
    throw this.SAVE_ERROR(new ud(c, this.LA(1), o));
  }
}
class xd {
  initContentAssist() {
  }
  computeContentAssist(e, n) {
    const r = this.gastProductionsCache[e];
    if (_e(r))
      throw Error(`Rule ->${e}<- does not exist in this grammar.`);
    return fi([r], n, this.tokenMatcher, this.maxLookahead);
  }
  // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...
  // TODO: should this be more explicitly part of the public API?
  getNextPossibleTokenTypes(e) {
    const n = ce(e.ruleStack), s = this.getGAstProductions()[n];
    return new wf(s, e).startWalking();
  }
}
const dn = {
  description: "This Object indicates the Parser is during Recording Phase"
};
Object.freeze(dn);
const As = !0, Rs = Math.pow(2, we) - 1, vi = C({ name: "RECORDING_PHASE_TOKEN", pattern: G.NA });
St([vi]);
const Pi = ur(
  vi,
  `This IToken indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,
  // Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
  // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
);
Object.freeze(Pi);
const bd = {
  name: `This CSTNode indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,
  children: {}
};
class wd {
  initGastRecorder(e) {
    this.recordingProdStack = [], this.RECORDING_PHASE = !1;
  }
  enableRecording() {
    this.RECORDING_PHASE = !0, this.TRACE_INIT("Enable Recording", () => {
      for (let e = 0; e < 10; e++) {
        const n = e > 0 ? e : "";
        this[`CONSUME${n}`] = function(r, s) {
          return this.consumeInternalRecord(r, e, s);
        }, this[`SUBRULE${n}`] = function(r, s) {
          return this.subruleInternalRecord(r, e, s);
        }, this[`OPTION${n}`] = function(r) {
          return this.optionInternalRecord(r, e);
        }, this[`OR${n}`] = function(r) {
          return this.orInternalRecord(r, e);
        }, this[`MANY${n}`] = function(r) {
          this.manyInternalRecord(e, r);
        }, this[`MANY_SEP${n}`] = function(r) {
          this.manySepFirstInternalRecord(e, r);
        }, this[`AT_LEAST_ONE${n}`] = function(r) {
          this.atLeastOneInternalRecord(e, r);
        }, this[`AT_LEAST_ONE_SEP${n}`] = function(r) {
          this.atLeastOneSepFirstInternalRecord(e, r);
        };
      }
      this.consume = function(e, n, r) {
        return this.consumeInternalRecord(n, e, r);
      }, this.subrule = function(e, n, r) {
        return this.subruleInternalRecord(n, e, r);
      }, this.option = function(e, n) {
        return this.optionInternalRecord(n, e);
      }, this.or = function(e, n) {
        return this.orInternalRecord(n, e);
      }, this.many = function(e, n) {
        this.manyInternalRecord(e, n);
      }, this.atLeastOne = function(e, n) {
        this.atLeastOneInternalRecord(e, n);
      }, this.ACTION = this.ACTION_RECORD, this.BACKTRACK = this.BACKTRACK_RECORD, this.LA = this.LA_RECORD;
    });
  }
  disableRecording() {
    this.RECORDING_PHASE = !1, this.TRACE_INIT("Deleting Recording methods", () => {
      const e = this;
      for (let n = 0; n < 10; n++) {
        const r = n > 0 ? n : "";
        delete e[`CONSUME${r}`], delete e[`SUBRULE${r}`], delete e[`OPTION${r}`], delete e[`OR${r}`], delete e[`MANY${r}`], delete e[`MANY_SEP${r}`], delete e[`AT_LEAST_ONE${r}`], delete e[`AT_LEAST_ONE_SEP${r}`];
      }
      delete e.consume, delete e.subrule, delete e.option, delete e.or, delete e.many, delete e.atLeastOne, delete e.ACTION, delete e.BACKTRACK, delete e.LA;
    });
  }
  //   Parser methods are called inside an ACTION?
  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?
  // @ts-expect-error -- noop place holder
  ACTION_RECORD(e) {
  }
  // Executing backtracking logic will break our recording logic assumptions
  BACKTRACK_RECORD(e, n) {
    return () => !0;
  }
  // LA is part of the official API and may be used for custom lookahead logic
  // by end users who may forget to wrap it in ACTION or inside a GATE
  LA_RECORD(e) {
    return Yt;
  }
  topLevelRuleRecord(e, n) {
    try {
      const r = new Qe({ definition: [], name: e });
      return r.name = e, this.recordingProdStack.push(r), n.call(this), this.recordingProdStack.pop(), r;
    } catch (r) {
      if (r.KNOWN_RECORDER_ERROR !== !0)
        try {
          r.message = r.message + `
	 This error was thrown during the "grammar recording phase" For more info see:
	https://chevrotain.io/docs/guide/internals.html#grammar-recording`;
        } catch {
          throw r;
        }
      throw r;
    }
  }
  // Implementation of parsing DSL
  optionInternalRecord(e, n) {
    return at.call(this, K, e, n);
  }
  atLeastOneInternalRecord(e, n) {
    at.call(this, me, n, e);
  }
  atLeastOneSepFirstInternalRecord(e, n) {
    at.call(this, Ae, n, e, As);
  }
  manyInternalRecord(e, n) {
    at.call(this, U, n, e);
  }
  manySepFirstInternalRecord(e, n) {
    at.call(this, le, n, e, As);
  }
  orInternalRecord(e, n) {
    return Ud.call(this, e, n);
  }
  subruleInternalRecord(e, n, r) {
    if (Vt(n), !e || R(e, "ruleName") === !1) {
      const o = new Error(`<SUBRULE${Is(n)}> argument is invalid expecting a Parser method reference but got: <${JSON.stringify(e)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);
      throw o.KNOWN_RECORDER_ERROR = !0, o;
    }
    const s = qe(this.recordingProdStack), i = e.ruleName, a = new X({
      idx: n,
      nonTerminalName: i,
      label: r?.LABEL,
      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
      referencedRule: void 0
    });
    return s.definition.push(a), this.outputCst ? bd : dn;
  }
  consumeInternalRecord(e, n, r) {
    if (Vt(n), !ui(e)) {
      const a = new Error(`<CONSUME${Is(n)}> argument is invalid expecting a TokenType reference but got: <${JSON.stringify(e)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);
      throw a.KNOWN_RECORDER_ERROR = !0, a;
    }
    const s = qe(this.recordingProdStack), i = new M({
      idx: n,
      terminalType: e,
      label: r?.LABEL
    });
    return s.definition.push(i), Pi;
  }
}
function at(t, e, n, r = !1) {
  Vt(n);
  const s = qe(this.recordingProdStack), i = Ne(e) ? e : e.DEF, a = new t({ definition: [], idx: n });
  return r && (a.separator = e.SEP), R(e, "MAX_LOOKAHEAD") && (a.maxLookahead = e.MAX_LOOKAHEAD), this.recordingProdStack.push(a), i.call(this), s.definition.push(a), this.recordingProdStack.pop(), dn;
}
function Ud(t, e) {
  Vt(e);
  const n = qe(this.recordingProdStack), r = N(t) === !1, s = r === !1 ? t : t.DEF, i = new he({
    definition: [],
    idx: e,
    ignoreAmbiguities: r && t.IGNORE_AMBIGUITIES === !0
  });
  R(t, "MAX_LOOKAHEAD") && (i.maxLookahead = t.MAX_LOOKAHEAD);
  const a = Zs(s, (o) => Ne(o.GATE));
  return i.hasPredicates = a, n.definition.push(i), S(s, (o) => {
    const c = new j({ definition: [] });
    i.definition.push(c), R(o, "IGNORE_AMBIGUITIES") ? c.ignoreAmbiguities = o.IGNORE_AMBIGUITIES : R(o, "GATE") && (c.ignoreAmbiguities = !0), this.recordingProdStack.push(c), o.ALT.call(this), this.recordingProdStack.pop();
  }), dn;
}
function Is(t) {
  return t === 0 ? "" : `${t}`;
}
function Vt(t) {
  if (t < 0 || t > Rs) {
    const e = new Error(
      // The stack trace will contain all the needed details
      `Invalid DSL Method idx value: <${t}>
	Idx value must be a none negative value smaller than ${Rs + 1}`
    );
    throw e.KNOWN_RECORDER_ERROR = !0, e;
  }
}
class Fd {
  initPerformanceTracer(e) {
    if (R(e, "traceInitPerf")) {
      const n = e.traceInitPerf, r = typeof n == "number";
      this.traceInitMaxIdent = r ? n : 1 / 0, this.traceInitPerf = r ? n > 0 : n;
    } else
      this.traceInitMaxIdent = 0, this.traceInitPerf = Oe.traceInitPerf;
    this.traceInitIndent = -1;
  }
  TRACE_INIT(e, n) {
    if (this.traceInitPerf === !0) {
      this.traceInitIndent++;
      const r = new Array(this.traceInitIndent + 1).join("	");
      this.traceInitIndent < this.traceInitMaxIdent && console.log(`${r}--> <${e}>`);
      const { time: s, value: i } = Js(n), a = s > 10 ? console.warn : console.log;
      return this.traceInitIndent < this.traceInitMaxIdent && a(`${r}<-- <${e}> time: ${s}ms`), this.traceInitIndent--, i;
    } else
      return n();
  }
}
function Dd(t, e) {
  e.forEach((n) => {
    const r = n.prototype;
    Object.getOwnPropertyNames(r).forEach((s) => {
      if (s === "constructor")
        return;
      const i = Object.getOwnPropertyDescriptor(r, s);
      i && (i.get || i.set) ? Object.defineProperty(t.prototype, s, i) : t.prototype[s] = n.prototype[s];
    });
  });
}
const Yt = ur(Be, "", NaN, NaN, NaN, NaN, NaN, NaN);
Object.freeze(Yt);
const Oe = Object.freeze({
  recoveryEnabled: !1,
  maxLookahead: 3,
  dynamicTokensEnabled: !1,
  outputCst: !0,
  errorMessageProvider: hi,
  nodeLocationTracking: "none",
  traceInitPerf: !1,
  skipValidations: !1
}), Xt = Object.freeze({
  recoveryValueFunc: () => {
  },
  resyncEnabled: !0
});
var B;
(function(t) {
  t[t.INVALID_RULE_NAME = 0] = "INVALID_RULE_NAME", t[t.DUPLICATE_RULE_NAME = 1] = "DUPLICATE_RULE_NAME", t[t.INVALID_RULE_OVERRIDE = 2] = "INVALID_RULE_OVERRIDE", t[t.DUPLICATE_PRODUCTIONS = 3] = "DUPLICATE_PRODUCTIONS", t[t.UNRESOLVED_SUBRULE_REF = 4] = "UNRESOLVED_SUBRULE_REF", t[t.LEFT_RECURSION = 5] = "LEFT_RECURSION", t[t.NONE_LAST_EMPTY_ALT = 6] = "NONE_LAST_EMPTY_ALT", t[t.AMBIGUOUS_ALTS = 7] = "AMBIGUOUS_ALTS", t[t.CONFLICT_TOKENS_RULES_NAMESPACE = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE", t[t.INVALID_TOKEN_NAME = 9] = "INVALID_TOKEN_NAME", t[t.NO_NON_EMPTY_LOOKAHEAD = 10] = "NO_NON_EMPTY_LOOKAHEAD", t[t.AMBIGUOUS_PREFIX_ALTS = 11] = "AMBIGUOUS_PREFIX_ALTS", t[t.TOO_MANY_ALTS = 12] = "TOO_MANY_ALTS", t[t.CUSTOM_LOOKAHEAD_VALIDATION = 13] = "CUSTOM_LOOKAHEAD_VALIDATION";
})(B || (B = {}));
class _t {
  /**
   *  @deprecated use the **instance** method with the same name instead
   */
  static performSelfAnalysis(e) {
    throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.");
  }
  performSelfAnalysis() {
    this.TRACE_INIT("performSelfAnalysis", () => {
      let e;
      this.selfAnalysisDone = !0;
      const n = this.className;
      this.TRACE_INIT("toFastProps", () => {
        ei(this);
      }), this.TRACE_INIT("Grammar Recording", () => {
        try {
          this.enableRecording(), S(this.definedRulesNames, (s) => {
            const a = this[s].originalGrammarAction;
            let o;
            this.TRACE_INIT(`${s} Rule`, () => {
              o = this.topLevelRuleRecord(s, a);
            }), this.gastProductionsCache[s] = o;
          });
        } finally {
          this.disableRecording();
        }
      });
      let r = [];
      if (this.TRACE_INIT("Grammar Resolving", () => {
        r = od({
          rules: w(this.gastProductionsCache)
        }), this.definitionErrors = this.definitionErrors.concat(r);
      }), this.TRACE_INIT("Grammar Validations", () => {
        if (v(r) && this.skipValidations === !1) {
          const s = cd({
            rules: w(this.gastProductionsCache),
            tokenTypes: w(this.tokensMap),
            errMsgProvider: De,
            grammarName: n
          }), i = zf({
            lookaheadStrategy: this.lookaheadStrategy,
            rules: w(this.gastProductionsCache),
            tokenTypes: w(this.tokensMap),
            grammarName: n
          });
          this.definitionErrors = this.definitionErrors.concat(s, i);
        }
      }), v(this.definitionErrors) && (this.recoveryEnabled && this.TRACE_INIT("computeAllProdsFollows", () => {
        const s = Dh(w(this.gastProductionsCache));
        this.resyncFollows = s;
      }), this.TRACE_INIT("ComputeLookaheadFunctions", () => {
        var s, i;
        (i = (s = this.lookaheadStrategy).initialize) === null || i === void 0 || i.call(s, {
          rules: w(this.gastProductionsCache)
        }), this.preComputeLookaheadFunctions(w(this.gastProductionsCache));
      })), !_t.DEFER_DEFINITION_ERRORS_HANDLING && !v(this.definitionErrors))
        throw e = A(this.definitionErrors, (s) => s.message), new Error(`Parser Definition Errors detected:
 ${e.join(`
-------------------------------
`)}`);
    });
  }
  constructor(e, n) {
    this.definitionErrors = [], this.selfAnalysisDone = !1;
    const r = this;
    if (r.initErrorHandler(n), r.initLexerAdapter(), r.initLooksAhead(n), r.initRecognizerEngine(e, n), r.initRecoverable(n), r.initTreeBuilder(n), r.initContentAssist(), r.initGastRecorder(n), r.initPerformanceTracer(n), R(n, "ignoredIssues"))
      throw new Error(`The <ignoredIssues> IParserConfig property has been deprecated.
	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.
	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES
	For further details.`);
    this.skipValidations = R(n, "skipValidations") ? n.skipValidations : Oe.skipValidations;
  }
}
_t.DEFER_DEFINITION_ERRORS_HANDLING = !1;
Dd(_t, [
  dd,
  Td,
  yd,
  vd,
  Md,
  Pd,
  kd,
  xd,
  wd,
  Fd
]);
class $d extends _t {
  constructor(e, n = Oe) {
    const r = D(n);
    r.outputCst = !0, super(e, r);
  }
}
const Mi = C({
  name: "HTML_COMMENT",
  pattern: /<!--[\s\S]*?-->/,
  line_breaks: !0
}), ki = C({
  name: "HTML_CONDITIONAL_COMMENT",
  pattern: /<!\[[\s\S]*?\]>/,
  line_breaks: !0
}), Gd = C({
  name: "XML",
  pattern: /<\?xml(?:.|\s)*?\?>/
}), xi = C({
  name: "CDATA",
  pattern: /<!\[CDATA\[[\s\S]*?]]>/
}), bi = C({
  name: "DTD",
  pattern: /<!.*?>/
}), wi = C({
  name: "SCRIPTLET",
  pattern: /<%(.*?)%>|<\?(.*?)\?>/
}), Bd = C({
  name: "SEA_WS",
  pattern: /[ \t]+/,
  group: G.SKIPPED
}), Ui = C({
  name: "LINE_BREAK",
  pattern: /\r?\n/
}), Fi = C({
  name: "SCRIPT_OPEN",
  pattern: /<script\b[^>]*>/,
  push_mode: "SCRIPT"
}), Di = C({
  name: "STYLE_OPEN",
  pattern: /<style\b[^>]*>/,
  push_mode: "STYLE"
}), Fn = C({
  name: "TAG_OPEN",
  pattern: /</,
  push_mode: "TAG"
}), $i = C({
  name: "HTML_TEXT",
  pattern: /[^<@]+/,
  line_breaks: !0
}), Dn = C({
  name: "TAG_CLOSE",
  pattern: />/,
  pop_mode: !0
}), Gi = C({
  name: "TAG_SLASH_CLOSE",
  pattern: /\/>/,
  pop_mode: !0
}), Bi = C({
  name: "TAG_SLASH",
  pattern: /\//
}), Hi = C({
  name: "TAG_EQUALS",
  pattern: /=/,
  push_mode: "ATTVALUE"
}), Dt = C({
  name: "TAG_NAME",
  pattern: /[:@a-zA-Z\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:\.\-@\u00B7\u0300-\u036F\u203F-\u2040.0-9a-zA-Z]*/
}), Hd = C({
  name: "TAG_WHITESPACE",
  pattern: /[ \t\r\n]+/,
  group: G.SKIPPED
}), Ki = C({
  name: "SCRIPT_BODY",
  pattern: /[\s\S]*?<\/script>/,
  pop_mode: !0
}), Wi = C({
  name: "STYLE_BODY",
  pattern: /[\s\S]*?<\/style>/,
  pop_mode: !0
}), ji = C({
  name: "ATTVALUE_VALUE",
  pattern: / *("[^<"]*"|'[^<']*'|[-_./+,?=:#;0-9a-zA-Z]+ ?|#[0-9a-fA-F]+|[0-9]+%?)/,
  pop_mode: !0
}), $n = C({
  name: "EDGE_COMMENT",
  pattern: /{{--[\s\S]*?--}}/,
  line_breaks: !0
}), Gn = C({
  name: "EDGE_MUSTACHE",
  pattern: /{{[\s\S]*?}}\s*/
}), Bn = C({
  name: "EDGE_SAFE_MUSTACHE",
  pattern: /{{{[\s\S]*?}}}\s*/
}), zi = C({
  name: "EDGE_ESCAPED_MUSTACHE",
  pattern: /@{{[\s\S]*?}}\s*/
}), Vi = C({
  name: "EDGE_TAG",
  pattern: /@(?:!?\w+(?:\.\w+)*)\s*(?:\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\))?~?/
}), Yi = C({
  name: "EDGE_TAG_PROP",
  pattern: /@(if|elseif|else|each|flashMessage)\([^)]*\)\s*([\s\S]*?)@end/
}), Hn = {
  defaultMode: "default",
  modes: {
    default: [
      Mi,
      ki,
      Gd,
      xi,
      bi,
      wi,
      Ui,
      Bd,
      Fi,
      Di,
      Fn,
      $n,
      zi,
      Bn,
      Gn,
      Vi,
      $i
    ],
    TAG: [
      Dn,
      Gi,
      Bi,
      Hi,
      $n,
      Bn,
      Gn,
      Yi,
      Dt,
      Hd
    ],
    SCRIPT: [Ki],
    STYLE: [Wi],
    ATTVALUE: [ji]
  }
}, Kd = () => {
  const t = [];
  for (const e in Hn.modes)
    t.push(...Hn.modes[e]);
  return t;
}, Wd = new G(Hn);
class Xi extends $d {
  constructor() {
    super(Kd());
    const e = this;
    e.RULE("document", () => {
      e.MANY(() => {
        e.SUBRULE(e.content);
      });
    }), e.RULE("content", () => {
      e.OR([
        { ALT: () => e.CONSUME($i) },
        { ALT: () => e.CONSUME(Ui) },
        { ALT: () => e.SUBRULE(e.element) },
        { ALT: () => e.SUBRULE(e.scriptlet) },
        { ALT: () => e.SUBRULE(e.htmlComment) },
        { ALT: () => e.SUBRULE(e.htmlConditionalComment) },
        { ALT: () => e.SUBRULE(e.cdata) },
        { ALT: () => e.SUBRULE(e.dtd) },
        { ALT: () => e.SUBRULE(e.scriptElement) },
        { ALT: () => e.SUBRULE(e.styleElement) },
        { ALT: () => e.SUBRULE(e.edgeComment) },
        { ALT: () => e.SUBRULE(e.edgeSafeMustache) },
        { ALT: () => e.SUBRULE(e.edgeMustache) },
        { ALT: () => e.SUBRULE(e.edgeEscapedMustache) },
        { ALT: () => e.SUBRULE(e.edgeTag) }
      ]);
    }), e.RULE("element", () => {
      e.OR([
        {
          ALT: () => e.SUBRULE(e.openingTag)
        },
        {
          ALT: () => e.SUBRULE(e.closingTag)
        }
      ]);
    }), e.RULE("openingTag", () => {
      e.CONSUME(Fn), e.CONSUME(Dt), e.MANY(() => {
        e.OR([
          { ALT: () => e.SUBRULE(e.edgeTagProp) },
          { ALT: () => e.SUBRULE(e.attribute) },
          { ALT: () => e.SUBRULE(e.edgeSafeMustache) },
          { ALT: () => e.SUBRULE(e.edgeMustache) },
          { ALT: () => e.SUBRULE(e.edgeComment) }
        ]);
      }), e.OR1([
        { ALT: () => e.CONSUME1(Gi) },
        { ALT: () => e.CONSUME1(Dn) }
      ]);
    }), e.RULE("attribute", () => {
      e.CONSUME(Dt), e.OPTION(() => {
        e.CONSUME(Hi), e.CONSUME(ji);
      });
    }), e.RULE("closingTag", () => {
      e.CONSUME(Fn), e.CONSUME(Bi), e.CONSUME(Dt), e.CONSUME(Dn);
    }), e.RULE("scriptlet", () => {
      e.CONSUME(wi);
    }), e.RULE("htmlComment", () => {
      e.CONSUME(Mi);
    }), e.RULE("htmlConditionalComment", () => {
      e.CONSUME(ki);
    }), e.RULE("cdata", () => {
      e.CONSUME(xi);
    }), e.RULE("dtd", () => {
      e.CONSUME(bi);
    }), e.RULE("scriptElement", () => {
      e.CONSUME(Fi), e.CONSUME(Ki);
    }), e.RULE("styleElement", () => {
      e.CONSUME(Di), e.CONSUME(Wi);
    }), e.RULE("edgeComment", () => {
      e.CONSUME($n);
    }), e.RULE("edgeMustache", () => {
      e.CONSUME(Gn);
    }), e.RULE("edgeSafeMustache", () => {
      e.CONSUME(Bn);
    }), e.RULE("edgeEscapedMustache", () => {
      e.CONSUME(zi);
    }), e.RULE("edgeTag", () => {
      e.CONSUME(Vi);
    }), e.RULE("edgeTagProp", () => {
      e.CONSUME(Yi);
    }), this.performSelfAnalysis();
  }
}
const jd = new Xi(), zd = jd.getBaseCstVisitorConstructor();
class Vd extends zd {
  #t = /* @__PURE__ */ new Set([
    "area",
    "base",
    "br",
    "col",
    "embed",
    "hr",
    "img",
    "input",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr",
    // Below are for SVGs
    "animateMotion",
    "animateTransform",
    "animate",
    "circle",
    "ellipse",
    "feGaussianBlur",
    "feDropShadow",
    "feOffset",
    "feBlend",
    "feColorMatrix",
    "feComposite",
    "feDisplacementMap",
    "feFlood",
    "feImage",
    "feMergeNode",
    "feMorphology",
    "fePointLight",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "image",
    "line",
    "mpath",
    "path",
    "polygon",
    "polyline",
    "rect",
    "set",
    "stop",
    "use",
    "view"
  ]);
  constructor() {
    super(), this.validateVisitor();
  }
  #e(e) {
    return this.#t.has(e);
  }
  document(e) {
    const n = e.content[0].startOffset, r = e.content[e.content.length - 1].endOffset;
    return {
      type: "document",
      children: e.content.map((s) => this.visit(s)),
      start: n,
      end: r
    };
  }
  content(e) {
    if (e.HTML_TEXT)
      return {
        type: "htmlText",
        value: e.HTML_TEXT[0].image,
        start: e.HTML_TEXT[0].startOffset,
        end: e.HTML_TEXT[0].endOffset
      };
    if (e.LINE_BREAK)
      return {
        type: "linebreak",
        value: e.LINE_BREAK[0].image,
        start: e.LINE_BREAK[0].startOffset,
        end: e.LINE_BREAK[0].endOffset
      };
    const n = e.element || e.scriptlet || e.htmlComment || e.htmlConditionalComment || e.cdata || e.dtd || e.scriptElement || e.styleElement || e.edgeComment || e.edgeMustache || e.edgeSafeMustache || e.edgeEscapedMustache || e.edgeTag || e.htmlText;
    return this.visit(n);
  }
  element(e) {
    return e.openingTag ? this.visit(e.openingTag) : e.selfClosingTag ? this.visit(e.selfClosingTag) : this.visit(e.closingTag);
  }
  openingTag(e) {
    const n = e.TAG_NAME[0].image, r = e.edgeSafeMustache ? e.edgeSafeMustache.map((l) => this.visit(l)) : [], s = e.edgeMustache ? e.edgeMustache.map((l) => this.visit(l)) : [], i = e.edgeTagProp ? e.edgeTagProp.map((l) => this.visit(l)) : [], a = e.attribute ? e.attribute.map((l) => this.visit(l)) : [], o = e.edgeComment ? e.edgeComment.map((l) => this.visit(l)) : [], c = e.TAG_NAME[0].startOffset, u = e.TAG_NAME[0].endOffset;
    return this.#e(n) || e.TAG_SLASH_CLOSE ? {
      type: "voidTag",
      tagName: n,
      edgeSafeMustaches: r,
      edgeMustaches: s,
      edgeTagProps: i,
      attributes: a,
      comments: o,
      start: c,
      end: u
    } : {
      type: "openingTag",
      tagName: n,
      edgeSafeMustaches: r,
      edgeMustaches: s,
      edgeTagProps: i,
      attributes: a,
      comments: o,
      start: c,
      end: u
    };
  }
  attribute(e) {
    const n = e.TAG_NAME[0].image, r = e.ATTVALUE_VALUE?.[0]?.image?.trim(), s = e.TAG_NAME[0].startOffset, i = e.ATTVALUE_VALUE ? e.ATTVALUE_VALUE[0].endOffset : e.TAG_NAME[0].endOffset;
    return { type: "attribute", attributeName: n, attributeValue: r, start: s, end: i };
  }
  closingTag(e) {
    const n = e.TAG_NAME[0].image, r = e.TAG_OPEN[0].startOffset, s = e.TAG_CLOSE[0].endOffset;
    return this.#e(n) ? {
      type: "doNotPrint"
    } : { type: "closingTag", tagName: n, start: r, end: s };
  }
  scriptlet(e) {
    const n = e.SCRIPTLET[0].image, r = e.SCRIPTLET[0].startOffset, s = e.SCRIPTLET[0].endOffset;
    return { type: "scriptlet", value: n, start: r, end: s };
  }
  htmlComment(e) {
    const n = e.HTML_COMMENT[0].image, r = e.HTML_COMMENT[0].startOffset, s = e.HTML_COMMENT[0].endOffset;
    return { type: "htmlComment", value: n, start: r, end: s };
  }
  htmlConditionalComment(e) {
    const n = e.HTML_CONDITIONAL_COMMENT[0].image, r = e.HTML_CONDITIONAL_COMMENT[0].startOffset, s = e.HTML_CONDITIONAL_COMMENT[0].endOffset;
    return { type: "htmlConditionalComment", value: n, start: r, end: s };
  }
  cdata(e) {
    const n = e.CDATA[0].image, r = e.CDATA[0].startOffset, s = e.CDATA[0].endOffset;
    return { type: "cdata", value: n, start: r, end: s };
  }
  dtd(e) {
    const n = e.DTD[0].image, r = e.DTD[0].startOffset, s = e.DTD[0].endOffset;
    return { type: "dtd", value: n, start: r, end: s };
  }
  scriptElement(e) {
    const n = e.SCRIPT_OPEN[0].image + e.SCRIPT_BODY[0].image, r = e.SCRIPT_OPEN[0].startOffset, s = e.SCRIPT_BODY[0].endOffset;
    return { type: "scriptElement", value: n, start: r, end: s };
  }
  styleElement(e) {
    const n = e.STYLE_OPEN[0].image + e.STYLE_BODY[0].image, r = e.STYLE_OPEN[0].startOffset, s = e.STYLE_BODY[0].endOffset;
    return { type: "styleElement", value: n, start: r, end: s };
  }
  edgeComment(e) {
    const n = e.EDGE_COMMENT[0].image, r = e.EDGE_COMMENT[0].startOffset, s = e.EDGE_COMMENT[0].endOffset;
    return { type: "edgeComment", value: n, start: r, end: s };
  }
  edgeMustache(e) {
    const n = e.EDGE_MUSTACHE[0].image, r = e.EDGE_MUSTACHE[0].startOffset, s = e.EDGE_MUSTACHE[0].endOffset;
    return { type: "edgeMustache", value: n, start: r, end: s };
  }
  edgeSafeMustache(e) {
    const n = e.EDGE_SAFE_MUSTACHE[0].image, r = e.EDGE_SAFE_MUSTACHE[0].startOffset, s = e.EDGE_SAFE_MUSTACHE[0].endOffset;
    return { type: "edgeSafeMustache", value: n, start: r, end: s };
  }
  edgeEscapedMustache(e) {
    const n = e.EDGE_ESCAPED_MUSTACHE[0].image, r = e.EDGE_ESCAPED_MUSTACHE[0].startOffset, s = e.EDGE_ESCAPED_MUSTACHE[0].endOffset;
    return { type: "edgeEscapedMustache", value: n, start: r, end: s };
  }
  edgeTag(e) {
    const n = e.EDGE_TAG[0].image, r = e.EDGE_TAG[0].startOffset, s = e.EDGE_TAG[0].endOffset;
    return { type: "edgeTag", value: n, start: r, end: s };
  }
  edgeTagProp(e) {
    const n = e.EDGE_TAG_PROP[0].image, r = e.EDGE_TAG_PROP[0].startOffset, s = e.EDGE_TAG_PROP[0].endOffset;
    return { type: "edgeTagProp", value: n, start: r, end: s };
  }
}
const Mt = new Xi(), Yd = new Vd();
function Xd(t) {
  const e = Wd.tokenize(t);
  Mt.input = e.tokens;
  const n = Mt.document();
  if (Mt.errors.length > 0)
    throw new Error(
      `Parsing Errors Detected: ${JSON.stringify(Mt.errors)}`
    );
  return Yd.visit(n);
}
export {
  Xd as default
};
